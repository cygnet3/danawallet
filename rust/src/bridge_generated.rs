#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.6.

use crate::api::*;
use core::panic::UnwindSafe;
use flutter_rust_bridge::rust2dart::IntoIntoDart;
use flutter_rust_bridge::*;
use std::ffi::c_void;
use std::sync::Arc;

// Section: imports

use crate::constants::OutputSpendStatus;
use crate::constants::OwnedOutput;
use crate::constants::Recipient;
use crate::constants::WalletType;
use crate::logger::LogEntry;
use crate::logger::LogLevel;
use crate::stream::ScanProgress;
use crate::stream::SyncStatus;

// Section: wire functions

fn wire_create_log_stream_impl(
    port_: MessagePort,
    level: impl Wire2Api<LogLevel> + UnwindSafe,
    log_dependencies: impl Wire2Api<bool> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "create_log_stream",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            let api_level = level.wire2api();
            let api_log_dependencies = log_dependencies.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(create_log_stream(
                    task_callback.stream_sink::<_, LogEntry>(),
                    api_level,
                    api_log_dependencies,
                ))
            }
        },
    )
}
fn wire_create_sync_stream_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "create_sync_stream",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            move |task_callback| {
                Result::<_, ()>::Ok(create_sync_stream(
                    task_callback.stream_sink::<_, SyncStatus>(),
                ))
            }
        },
    )
}
fn wire_create_scan_progress_stream_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "create_scan_progress_stream",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            move |task_callback| {
                Result::<_, ()>::Ok(create_scan_progress_stream(
                    task_callback.stream_sink::<_, ScanProgress>(),
                ))
            }
        },
    )
}
fn wire_create_amount_stream_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "create_amount_stream",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            move |task_callback| {
                Result::<_, ()>::Ok(create_amount_stream(task_callback.stream_sink::<_, u64>()))
            }
        },
    )
}
fn wire_wallet_exists_impl(
    port_: MessagePort,
    label: impl Wire2Api<String> + UnwindSafe,
    files_dir: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "wallet_exists",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_label = label.wire2api();
            let api_files_dir = files_dir.wire2api();
            move |task_callback| Result::<_, ()>::Ok(wallet_exists(api_label, api_files_dir))
        },
    )
}
fn wire_setup_impl(
    port_: MessagePort,
    label: impl Wire2Api<String> + UnwindSafe,
    files_dir: impl Wire2Api<String> + UnwindSafe,
    wallet_type: impl Wire2Api<WalletType> + UnwindSafe,
    birthday: impl Wire2Api<u32> + UnwindSafe,
    is_testnet: impl Wire2Api<bool> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "setup",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_label = label.wire2api();
            let api_files_dir = files_dir.wire2api();
            let api_wallet_type = wallet_type.wire2api();
            let api_birthday = birthday.wire2api();
            let api_is_testnet = is_testnet.wire2api();
            move |task_callback| {
                setup(
                    api_label,
                    api_files_dir,
                    api_wallet_type,
                    api_birthday,
                    api_is_testnet,
                )
            }
        },
    )
}
fn wire_change_birthday_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
    birthday: impl Wire2Api<u32> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "change_birthday",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            let api_birthday = birthday.wire2api();
            move |task_callback| change_birthday(api_path, api_label, api_birthday)
        },
    )
}
fn wire_reset_wallet_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "reset_wallet",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| reset_wallet(api_path, api_label)
        },
    )
}
fn wire_remove_wallet_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "remove_wallet",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| remove_wallet(api_path, api_label)
        },
    )
}
fn wire_sync_blockchain_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "sync_blockchain",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| sync_blockchain(),
    )
}
fn wire_scan_to_tip_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "scan_to_tip",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| scan_to_tip(api_path, api_label)
        },
    )
}
fn wire_get_wallet_info_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, WalletStatus, _>(
        WrapInfo {
            debug_name: "get_wallet_info",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| get_wallet_info(api_path, api_label)
        },
    )
}
fn wire_get_receiving_address_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "get_receiving_address",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| get_receiving_address(api_path, api_label)
        },
    )
}
fn wire_get_spendable_outputs_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<OwnedOutput>, _>(
        WrapInfo {
            debug_name: "get_spendable_outputs",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| get_spendable_outputs(api_path, api_label)
        },
    )
}
fn wire_get_outputs_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<OwnedOutput>, _>(
        WrapInfo {
            debug_name: "get_outputs",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| get_outputs(api_path, api_label)
        },
    )
}
fn wire_create_new_psbt_impl(
    port_: MessagePort,
    label: impl Wire2Api<String> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
    inputs: impl Wire2Api<Vec<OwnedOutput>> + UnwindSafe,
    recipients: impl Wire2Api<Vec<Recipient>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "create_new_psbt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_label = label.wire2api();
            let api_path = path.wire2api();
            let api_inputs = inputs.wire2api();
            let api_recipients = recipients.wire2api();
            move |task_callback| create_new_psbt(api_label, api_path, api_inputs, api_recipients)
        },
    )
}
fn wire_add_fee_for_fee_rate_impl(
    port_: MessagePort,
    psbt: impl Wire2Api<String> + UnwindSafe,
    fee_rate: impl Wire2Api<u32> + UnwindSafe,
    payer: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "add_fee_for_fee_rate",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt = psbt.wire2api();
            let api_fee_rate = fee_rate.wire2api();
            let api_payer = payer.wire2api();
            move |task_callback| add_fee_for_fee_rate(api_psbt, api_fee_rate, api_payer)
        },
    )
}
fn wire_fill_sp_outputs_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
    psbt: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "fill_sp_outputs",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            let api_psbt = psbt.wire2api();
            move |task_callback| fill_sp_outputs(api_path, api_label, api_psbt)
        },
    )
}
fn wire_sign_psbt_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
    psbt: impl Wire2Api<String> + UnwindSafe,
    finalize: impl Wire2Api<bool> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "sign_psbt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            let api_psbt = psbt.wire2api();
            let api_finalize = finalize.wire2api();
            move |task_callback| sign_psbt(api_path, api_label, api_psbt, api_finalize)
        },
    )
}
fn wire_extract_tx_from_psbt_impl(port_: MessagePort, psbt: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "extract_tx_from_psbt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt = psbt.wire2api();
            move |task_callback| extract_tx_from_psbt(api_psbt)
        },
    )
}
fn wire_broadcast_tx_impl(port_: MessagePort, tx: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "broadcast_tx",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| broadcast_tx(api_tx)
        },
    )
}
fn wire_mark_transaction_inputs_as_spent_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "mark_transaction_inputs_as_spent",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            let api_tx = tx.wire2api();
            move |task_callback| mark_transaction_inputs_as_spent(api_path, api_label, api_tx)
        },
    )
}
fn wire_show_mnemonic_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
    label: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Option<String>, _>(
        WrapInfo {
            debug_name: "show_mnemonic",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            let api_label = label.wire2api();
            move |task_callback| show_mnemonic(api_path, api_label)
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<i32> for i32 {
    fn wire2api(self) -> i32 {
        self
    }
}

impl Wire2Api<LogLevel> for i32 {
    fn wire2api(self) -> LogLevel {
        match self {
            0 => LogLevel::Debug,
            1 => LogLevel::Info,
            2 => LogLevel::Warn,
            3 => LogLevel::Error,
            4 => LogLevel::Off,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}

impl Wire2Api<u32> for u32 {
    fn wire2api(self) -> u32 {
        self
    }
}
impl Wire2Api<u64> for u64 {
    fn wire2api(self) -> u64 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

// Section: impl IntoDart

impl support::IntoDart for LogEntry {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.time_millis.into_into_dart().into_dart(),
            self.level.into_into_dart().into_dart(),
            self.tag.into_into_dart().into_dart(),
            self.msg.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for LogEntry {}
impl rust2dart::IntoIntoDart<LogEntry> for LogEntry {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for OutputSpendStatus {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Unspent => vec![0.into_dart()],
            Self::Spent(field0) => vec![1.into_dart(), field0.into_into_dart().into_dart()],
            Self::Mined(field0) => vec![2.into_dart(), field0.into_into_dart().into_dart()],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for OutputSpendStatus {}
impl rust2dart::IntoIntoDart<OutputSpendStatus> for OutputSpendStatus {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for OwnedOutput {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.txoutpoint.into_into_dart().into_dart(),
            self.blockheight.into_into_dart().into_dart(),
            self.tweak.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.script.into_into_dart().into_dart(),
            self.label.into_dart(),
            self.spend_status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for OwnedOutput {}
impl rust2dart::IntoIntoDart<OwnedOutput> for OwnedOutput {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for ScanProgress {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.start.into_into_dart().into_dart(),
            self.current.into_into_dart().into_dart(),
            self.end.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ScanProgress {}
impl rust2dart::IntoIntoDart<ScanProgress> for ScanProgress {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for SyncStatus {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.peer_count.into_into_dart().into_dart(),
            self.blockheight.into_into_dart().into_dart(),
            self.bestblockhash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for SyncStatus {}
impl rust2dart::IntoIntoDart<SyncStatus> for SyncStatus {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for WalletStatus {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.amount.into_into_dart().into_dart(),
            self.birthday.into_into_dart().into_dart(),
            self.scan_height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for WalletStatus {}
impl rust2dart::IntoIntoDart<WalletStatus> for WalletStatus {
    fn into_into_dart(self) -> Self {
        self
    }
}

// Section: executor

support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler = Default::default();
}

#[cfg(not(target_family = "wasm"))]
#[path = "bridge_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use self::io::*;
