// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bridge_definitions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$OutputSpendStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OutputSpendStatusCopyWith<$Res> {
  factory $OutputSpendStatusCopyWith(
          OutputSpendStatus value, $Res Function(OutputSpendStatus) then) =
      _$OutputSpendStatusCopyWithImpl<$Res, OutputSpendStatus>;
}

/// @nodoc
class _$OutputSpendStatusCopyWithImpl<$Res, $Val extends OutputSpendStatus>
    implements $OutputSpendStatusCopyWith<$Res> {
  _$OutputSpendStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$OutputSpendStatus_UnspentCopyWith<$Res> {
  factory _$$OutputSpendStatus_UnspentCopyWith(
          _$OutputSpendStatus_Unspent value,
          $Res Function(_$OutputSpendStatus_Unspent) then) =
      __$$OutputSpendStatus_UnspentCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OutputSpendStatus_UnspentCopyWithImpl<$Res>
    extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_Unspent>
    implements _$$OutputSpendStatus_UnspentCopyWith<$Res> {
  __$$OutputSpendStatus_UnspentCopyWithImpl(_$OutputSpendStatus_Unspent _value,
      $Res Function(_$OutputSpendStatus_Unspent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OutputSpendStatus_Unspent implements OutputSpendStatus_Unspent {
  const _$OutputSpendStatus_Unspent();

  @override
  String toString() {
    return 'OutputSpendStatus.unspent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OutputSpendStatus_Unspent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return unspent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return unspent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (unspent != null) {
      return unspent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) {
    return unspent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) {
    return unspent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (unspent != null) {
      return unspent(this);
    }
    return orElse();
  }
}

abstract class OutputSpendStatus_Unspent implements OutputSpendStatus {
  const factory OutputSpendStatus_Unspent() = _$OutputSpendStatus_Unspent;
}

/// @nodoc
abstract class _$$OutputSpendStatus_SpentCopyWith<$Res> {
  factory _$$OutputSpendStatus_SpentCopyWith(_$OutputSpendStatus_Spent value,
          $Res Function(_$OutputSpendStatus_Spent) then) =
      __$$OutputSpendStatus_SpentCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$OutputSpendStatus_SpentCopyWithImpl<$Res>
    extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_Spent>
    implements _$$OutputSpendStatus_SpentCopyWith<$Res> {
  __$$OutputSpendStatus_SpentCopyWithImpl(_$OutputSpendStatus_Spent _value,
      $Res Function(_$OutputSpendStatus_Spent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$OutputSpendStatus_Spent(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$OutputSpendStatus_Spent implements OutputSpendStatus_Spent {
  const _$OutputSpendStatus_Spent(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'OutputSpendStatus.spent(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OutputSpendStatus_Spent &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OutputSpendStatus_SpentCopyWith<_$OutputSpendStatus_Spent> get copyWith =>
      __$$OutputSpendStatus_SpentCopyWithImpl<_$OutputSpendStatus_Spent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return spent(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return spent?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (spent != null) {
      return spent(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) {
    return spent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) {
    return spent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (spent != null) {
      return spent(this);
    }
    return orElse();
  }
}

abstract class OutputSpendStatus_Spent implements OutputSpendStatus {
  const factory OutputSpendStatus_Spent(final String field0) =
      _$OutputSpendStatus_Spent;

  String get field0;
  @JsonKey(ignore: true)
  _$$OutputSpendStatus_SpentCopyWith<_$OutputSpendStatus_Spent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OutputSpendStatus_MinedCopyWith<$Res> {
  factory _$$OutputSpendStatus_MinedCopyWith(_$OutputSpendStatus_Mined value,
          $Res Function(_$OutputSpendStatus_Mined) then) =
      __$$OutputSpendStatus_MinedCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$OutputSpendStatus_MinedCopyWithImpl<$Res>
    extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_Mined>
    implements _$$OutputSpendStatus_MinedCopyWith<$Res> {
  __$$OutputSpendStatus_MinedCopyWithImpl(_$OutputSpendStatus_Mined _value,
      $Res Function(_$OutputSpendStatus_Mined) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$OutputSpendStatus_Mined(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$OutputSpendStatus_Mined implements OutputSpendStatus_Mined {
  const _$OutputSpendStatus_Mined(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'OutputSpendStatus.mined(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OutputSpendStatus_Mined &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OutputSpendStatus_MinedCopyWith<_$OutputSpendStatus_Mined> get copyWith =>
      __$$OutputSpendStatus_MinedCopyWithImpl<_$OutputSpendStatus_Mined>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return mined(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return mined?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (mined != null) {
      return mined(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) {
    return mined(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) {
    return mined?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (mined != null) {
      return mined(this);
    }
    return orElse();
  }
}

abstract class OutputSpendStatus_Mined implements OutputSpendStatus {
  const factory OutputSpendStatus_Mined(final String field0) =
      _$OutputSpendStatus_Mined;

  String get field0;
  @JsonKey(ignore: true)
  _$$OutputSpendStatus_MinedCopyWith<_$OutputSpendStatus_Mined> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WalletType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) privateKeys,
    required TResult Function(String field0, String field1) readOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? privateKeys,
    TResult? Function(String field0, String field1)? readOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? privateKeys,
    TResult Function(String field0, String field1)? readOnly,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(WalletType_New value) $default, {
    required TResult Function(WalletType_Mnemonic value) mnemonic,
    required TResult Function(WalletType_PrivateKeys value) privateKeys,
    required TResult Function(WalletType_ReadOnly value) readOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(WalletType_New value)? $default, {
    TResult? Function(WalletType_Mnemonic value)? mnemonic,
    TResult? Function(WalletType_PrivateKeys value)? privateKeys,
    TResult? Function(WalletType_ReadOnly value)? readOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(WalletType_New value)? $default, {
    TResult Function(WalletType_Mnemonic value)? mnemonic,
    TResult Function(WalletType_PrivateKeys value)? privateKeys,
    TResult Function(WalletType_ReadOnly value)? readOnly,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WalletTypeCopyWith<$Res> {
  factory $WalletTypeCopyWith(
          WalletType value, $Res Function(WalletType) then) =
      _$WalletTypeCopyWithImpl<$Res, WalletType>;
}

/// @nodoc
class _$WalletTypeCopyWithImpl<$Res, $Val extends WalletType>
    implements $WalletTypeCopyWith<$Res> {
  _$WalletTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WalletType_NewCopyWith<$Res> {
  factory _$$WalletType_NewCopyWith(
          _$WalletType_New value, $Res Function(_$WalletType_New) then) =
      __$$WalletType_NewCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WalletType_NewCopyWithImpl<$Res>
    extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_New>
    implements _$$WalletType_NewCopyWith<$Res> {
  __$$WalletType_NewCopyWithImpl(
      _$WalletType_New _value, $Res Function(_$WalletType_New) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WalletType_New implements WalletType_New {
  const _$WalletType_New();

  @override
  String toString() {
    return 'WalletType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WalletType_New);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) privateKeys,
    required TResult Function(String field0, String field1) readOnly,
  }) {
    return $default();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? privateKeys,
    TResult? Function(String field0, String field1)? readOnly,
  }) {
    return $default?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? privateKeys,
    TResult Function(String field0, String field1)? readOnly,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(WalletType_New value) $default, {
    required TResult Function(WalletType_Mnemonic value) mnemonic,
    required TResult Function(WalletType_PrivateKeys value) privateKeys,
    required TResult Function(WalletType_ReadOnly value) readOnly,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(WalletType_New value)? $default, {
    TResult? Function(WalletType_Mnemonic value)? mnemonic,
    TResult? Function(WalletType_PrivateKeys value)? privateKeys,
    TResult? Function(WalletType_ReadOnly value)? readOnly,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(WalletType_New value)? $default, {
    TResult Function(WalletType_Mnemonic value)? mnemonic,
    TResult Function(WalletType_PrivateKeys value)? privateKeys,
    TResult Function(WalletType_ReadOnly value)? readOnly,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class WalletType_New implements WalletType {
  const factory WalletType_New() = _$WalletType_New;
}

/// @nodoc
abstract class _$$WalletType_MnemonicCopyWith<$Res> {
  factory _$$WalletType_MnemonicCopyWith(_$WalletType_Mnemonic value,
          $Res Function(_$WalletType_Mnemonic) then) =
      __$$WalletType_MnemonicCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$WalletType_MnemonicCopyWithImpl<$Res>
    extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_Mnemonic>
    implements _$$WalletType_MnemonicCopyWith<$Res> {
  __$$WalletType_MnemonicCopyWithImpl(
      _$WalletType_Mnemonic _value, $Res Function(_$WalletType_Mnemonic) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$WalletType_Mnemonic(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$WalletType_Mnemonic implements WalletType_Mnemonic {
  const _$WalletType_Mnemonic(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'WalletType.mnemonic(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletType_Mnemonic &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletType_MnemonicCopyWith<_$WalletType_Mnemonic> get copyWith =>
      __$$WalletType_MnemonicCopyWithImpl<_$WalletType_Mnemonic>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) privateKeys,
    required TResult Function(String field0, String field1) readOnly,
  }) {
    return mnemonic(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? privateKeys,
    TResult? Function(String field0, String field1)? readOnly,
  }) {
    return mnemonic?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? privateKeys,
    TResult Function(String field0, String field1)? readOnly,
    required TResult orElse(),
  }) {
    if (mnemonic != null) {
      return mnemonic(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(WalletType_New value) $default, {
    required TResult Function(WalletType_Mnemonic value) mnemonic,
    required TResult Function(WalletType_PrivateKeys value) privateKeys,
    required TResult Function(WalletType_ReadOnly value) readOnly,
  }) {
    return mnemonic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(WalletType_New value)? $default, {
    TResult? Function(WalletType_Mnemonic value)? mnemonic,
    TResult? Function(WalletType_PrivateKeys value)? privateKeys,
    TResult? Function(WalletType_ReadOnly value)? readOnly,
  }) {
    return mnemonic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(WalletType_New value)? $default, {
    TResult Function(WalletType_Mnemonic value)? mnemonic,
    TResult Function(WalletType_PrivateKeys value)? privateKeys,
    TResult Function(WalletType_ReadOnly value)? readOnly,
    required TResult orElse(),
  }) {
    if (mnemonic != null) {
      return mnemonic(this);
    }
    return orElse();
  }
}

abstract class WalletType_Mnemonic implements WalletType {
  const factory WalletType_Mnemonic(final String field0) =
      _$WalletType_Mnemonic;

  String get field0;
  @JsonKey(ignore: true)
  _$$WalletType_MnemonicCopyWith<_$WalletType_Mnemonic> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WalletType_PrivateKeysCopyWith<$Res> {
  factory _$$WalletType_PrivateKeysCopyWith(_$WalletType_PrivateKeys value,
          $Res Function(_$WalletType_PrivateKeys) then) =
      __$$WalletType_PrivateKeysCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1});
}

/// @nodoc
class __$$WalletType_PrivateKeysCopyWithImpl<$Res>
    extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_PrivateKeys>
    implements _$$WalletType_PrivateKeysCopyWith<$Res> {
  __$$WalletType_PrivateKeysCopyWithImpl(_$WalletType_PrivateKeys _value,
      $Res Function(_$WalletType_PrivateKeys) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$WalletType_PrivateKeys(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$WalletType_PrivateKeys implements WalletType_PrivateKeys {
  const _$WalletType_PrivateKeys(this.field0, this.field1);

  @override
  final String field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'WalletType.privateKeys(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletType_PrivateKeys &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletType_PrivateKeysCopyWith<_$WalletType_PrivateKeys> get copyWith =>
      __$$WalletType_PrivateKeysCopyWithImpl<_$WalletType_PrivateKeys>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) privateKeys,
    required TResult Function(String field0, String field1) readOnly,
  }) {
    return privateKeys(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? privateKeys,
    TResult? Function(String field0, String field1)? readOnly,
  }) {
    return privateKeys?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? privateKeys,
    TResult Function(String field0, String field1)? readOnly,
    required TResult orElse(),
  }) {
    if (privateKeys != null) {
      return privateKeys(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(WalletType_New value) $default, {
    required TResult Function(WalletType_Mnemonic value) mnemonic,
    required TResult Function(WalletType_PrivateKeys value) privateKeys,
    required TResult Function(WalletType_ReadOnly value) readOnly,
  }) {
    return privateKeys(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(WalletType_New value)? $default, {
    TResult? Function(WalletType_Mnemonic value)? mnemonic,
    TResult? Function(WalletType_PrivateKeys value)? privateKeys,
    TResult? Function(WalletType_ReadOnly value)? readOnly,
  }) {
    return privateKeys?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(WalletType_New value)? $default, {
    TResult Function(WalletType_Mnemonic value)? mnemonic,
    TResult Function(WalletType_PrivateKeys value)? privateKeys,
    TResult Function(WalletType_ReadOnly value)? readOnly,
    required TResult orElse(),
  }) {
    if (privateKeys != null) {
      return privateKeys(this);
    }
    return orElse();
  }
}

abstract class WalletType_PrivateKeys implements WalletType {
  const factory WalletType_PrivateKeys(
      final String field0, final String field1) = _$WalletType_PrivateKeys;

  String get field0;
  String get field1;
  @JsonKey(ignore: true)
  _$$WalletType_PrivateKeysCopyWith<_$WalletType_PrivateKeys> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WalletType_ReadOnlyCopyWith<$Res> {
  factory _$$WalletType_ReadOnlyCopyWith(_$WalletType_ReadOnly value,
          $Res Function(_$WalletType_ReadOnly) then) =
      __$$WalletType_ReadOnlyCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1});
}

/// @nodoc
class __$$WalletType_ReadOnlyCopyWithImpl<$Res>
    extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_ReadOnly>
    implements _$$WalletType_ReadOnlyCopyWith<$Res> {
  __$$WalletType_ReadOnlyCopyWithImpl(
      _$WalletType_ReadOnly _value, $Res Function(_$WalletType_ReadOnly) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$WalletType_ReadOnly(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$WalletType_ReadOnly implements WalletType_ReadOnly {
  const _$WalletType_ReadOnly(this.field0, this.field1);

  @override
  final String field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'WalletType.readOnly(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletType_ReadOnly &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletType_ReadOnlyCopyWith<_$WalletType_ReadOnly> get copyWith =>
      __$$WalletType_ReadOnlyCopyWithImpl<_$WalletType_ReadOnly>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) privateKeys,
    required TResult Function(String field0, String field1) readOnly,
  }) {
    return readOnly(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? privateKeys,
    TResult? Function(String field0, String field1)? readOnly,
  }) {
    return readOnly?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? privateKeys,
    TResult Function(String field0, String field1)? readOnly,
    required TResult orElse(),
  }) {
    if (readOnly != null) {
      return readOnly(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(WalletType_New value) $default, {
    required TResult Function(WalletType_Mnemonic value) mnemonic,
    required TResult Function(WalletType_PrivateKeys value) privateKeys,
    required TResult Function(WalletType_ReadOnly value) readOnly,
  }) {
    return readOnly(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(WalletType_New value)? $default, {
    TResult? Function(WalletType_Mnemonic value)? mnemonic,
    TResult? Function(WalletType_PrivateKeys value)? privateKeys,
    TResult? Function(WalletType_ReadOnly value)? readOnly,
  }) {
    return readOnly?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(WalletType_New value)? $default, {
    TResult Function(WalletType_Mnemonic value)? mnemonic,
    TResult Function(WalletType_PrivateKeys value)? privateKeys,
    TResult Function(WalletType_ReadOnly value)? readOnly,
    required TResult orElse(),
  }) {
    if (readOnly != null) {
      return readOnly(this);
    }
    return orElse();
  }
}

abstract class WalletType_ReadOnly implements WalletType {
  const factory WalletType_ReadOnly(final String field0, final String field1) =
      _$WalletType_ReadOnly;

  String get field0;
  String get field1;
  @JsonKey(ignore: true)
  _$$WalletType_ReadOnlyCopyWith<_$WalletType_ReadOnly> get copyWith =>
      throw _privateConstructorUsedError;
}
