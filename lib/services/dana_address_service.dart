import 'dart:convert';
import 'dart:math';
import 'package:crypto/crypto.dart';
import 'package:danawallet/data/enums/network.dart';
import 'package:danawallet/generated/rust/api/bip39.dart';
import 'package:danawallet/repositories/name_server_repository.dart';
import 'package:danawallet/services/bip353_resolver.dart';
import 'package:logger/logger.dart';

class DanaAddressService {
  final NameServerRepository nameServerRepository = NameServerRepository();
  final Random _random = Random.secure();
  String? _domain;

  // private constructor
  DanaAddressService._internal();

  static final DanaAddressService _instance = DanaAddressService._internal();

  factory DanaAddressService() {
    return _instance;
  }

  Future<String> get danaAddressDomain async {
    // lazy initialization of domain
    _domain ??= (await nameServerRepository.getInfo()).domain;

    return _domain!;
  }

  /// Generates a unique ID for requests without external dependencies
  /// Format: timestamp-randomhex (e.g., "1699889234567-a3f2c9d8")
  String _generateUniqueId() {
    final timestamp = DateTime.now().microsecondsSinceEpoch;
    final randomHex =
        _random.nextInt(0xFFFFFFFF).toRadixString(16).padLeft(8, '0');
    return '$timestamp-$randomHex';
  }

  /// Generates a deterministic 3-word alias from entropy using BIP39 wordlist
  /// The alias is generated by using the entropy bytes to select words
  /// [entropy] - The entropy bytes (typically from a SHA-256 hash)
  /// [offset] - Byte offset into the entropy (0, 6, 12, 18, etc.) to use different parts
  String _generateRandomDanaAddress(
      {required String spAddress, required int offset}) {
    final entropy = _generateEntropyFromAddress(spAddress);

    final wordlist = getEnglishWordlist();
    final wordlistSize = wordlist.length;

    // Ensure we have enough bytes for the offset
    if (offset + 6 > entropy.length) {
      // If offset is too large, wrap around using modulo
      offset = offset % (entropy.length - 5);
    }

    // Use different parts of the entropy to select 2 words and 1 number
    // This ensures deterministic selection while avoiding collisions
    final word1Index =
        (entropy[offset] << 8 | entropy[offset + 1]) % wordlistSize;
    final word2Index =
        (entropy[offset + 2] << 8 | entropy[offset + 3]) % wordlistSize;
    final numericValue =
        (entropy[offset + 4] << 8 | entropy[offset + 5]) % 1000;

    return '${wordlist[word1Index]}-${wordlist[word2Index]}-$numericValue';
  }

  /// Generates entropy (SHA-256 hash) from an address
  List<int> _generateEntropyFromAddress(String spAddress) {
    final bytes = utf8.encode(spAddress);
    final hash = sha256.convert(bytes);
    return hash.bytes;
  }

  /// Generate an available dana address by trying different username candidates
  /// Returns the first available username found within maxRetries attempts, or null if all are taken
  Future<String?> generateAvailableDanaAddress({
    required String spAddress,
    required int maxRetries,
    required Network network,
  }) async {
    for (int attempt = 0; attempt < maxRetries; attempt++) {
      final username = _generateRandomDanaAddress(
        spAddress: spAddress,
        offset:
            attempt * 6, // Each attempt uses 6 bytes (2 bytes per word/number)
      );
      final isAvailable = await isDanaUsernameAvailable(username, network);
      if (isAvailable) {
        return username;
      }
    }
    return null;
  }

  /// Creates a dana address by calling the external name_server
  ///
  /// [danaAddress] - The address to register.
  /// [requestId] - The unique id for this request, can be useful for tracking requests.
  ///
  /// Returns [DanaAddressCreationResponse] with the created address or error details
  Future<String> registerUser({
    required String username,
    required String spAddress,
    required Network network,
  }) async {
    final requestId = _generateUniqueId();
    final domain = await danaAddressDomain;

    // We try to resolve the address first to see if it already exists
    try {
      final resolvedSpAddress =
          await Bip353Resolver.resolve(username, domain, network);
      if (resolvedSpAddress == null) {
        // Address not registered yet, proceed with registration
        Logger().i(
            'Address $username@$domain not found, proceeding with registration');
      } else if (resolvedSpAddress == spAddress) {
        // If we find our address, return success there's nothing more to do
        return "$username@$domain";
      } else if (resolvedSpAddress != spAddress) {
        // If we find another address, return error, user must try with a different username
        throw Exception("Dana address already in use");
      }
    } catch (e) {
      // Network or parsing error - we'll let name server try and if it exists it will return an error
      Logger().e('Failed to resolve address for user $username: $e');
      rethrow;
    }

    Logger()
        .d('Registering dana username: $username with request ID: $requestId');
    return await nameServerRepository.registerDanaAddress(
        username: username,
        domain: domain,
        spAddress: spAddress,
        requestId: requestId);
  }

  /// Looks up dana addresses associated with a silent payment address
  ///
  /// [spAddress] - The Silent Payment address to lookup
  ///
  /// Returns a list of dana addresses in the format `user_name@danawallet.app`
  /// Returns an empty list if no addresses are found
  /// Throws an exception for network errors, invalid responses, or malformed data
  Future<String?> lookupDanaAddress(String spAddress) async {
    if (spAddress.isEmpty) {
      throw ArgumentError("Silent payment address cannot be empty");
    }

    final requestId = _generateUniqueId();
    Logger().d(
        'Looking up dana addresses for SP address: ${spAddress.substring(0, 20)}... (request ID: $requestId)');
    final addresses =
        await nameServerRepository.lookupDanaAddresses(spAddress, requestId);

    // Validate that addresses are in the correct format (user_name@domain)
    final validAddressPattern =
        RegExp(r'^[a-z0-9._-]+@[a-z0-9.-]+\.[a-z]+$', caseSensitive: false);
    final validAddresses = addresses.where((addr) {
      final isValid = validAddressPattern.hasMatch(addr);
      if (!isValid) {
        Logger().w('Invalid dana address format returned from lookup: "$addr"');
      }
      return isValid;
    }).toList();

    Logger().i(
        'Found ${validAddresses.length} valid dana address(es) for SP address');
    if (validAddresses.isNotEmpty) {
      // return the first valid address
      return validAddresses[0];
    } else {
      return null;
    }
  }

  /// Check if a dana address is available for registration
  /// Returns true if the dana address is not taken, false otherwise
  Future<bool> isDanaUsernameAvailable(String username, Network network) async {
    try {
      final domain = await danaAddressDomain;
      return await Bip353Resolver.isBip353AddressPresent(
          username, domain, network);
    } catch (e) {
      // If we can't resolve due to network error, assume it's taken to be safe
      Logger().e('Error checking address availability: $e');
      return false;
    }
  }
}
