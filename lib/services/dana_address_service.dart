import 'dart:convert';
import 'dart:math';
import 'package:crypto/crypto.dart';
import 'package:danawallet/data/enums/network.dart';
import 'package:danawallet/data/models/bip353_address.dart';
import 'package:danawallet/data/models/prefix_search_response.dart';
import 'package:danawallet/generated/rust/api/bip39.dart';
import 'package:danawallet/repositories/name_server_repository.dart';
import 'package:danawallet/services/bip353_resolver.dart';
import 'package:logger/logger.dart';

class DanaAddressService {
  NameServerRepository nameServerRepository;
  final Network network;
  final Random _random = Random.secure();
  String? _domain;

  DanaAddressService({required this.network})
      : nameServerRepository = NameServerRepository(network: network);

  Future<String> get danaAddressDomain async {
    // lazy initialization of domain
    _domain ??= (await nameServerRepository.getInfo()).domain;

    return _domain!;
  }

  /// Generates a unique ID for requests without external dependencies
  /// Format: timestamp-randomhex (e.g., "1699889234567-a3f2c9d8")
  String _generateUniqueId() {
    final timestamp = DateTime.now().microsecondsSinceEpoch;
    final randomHex =
        _random.nextInt(0xFFFFFFFF).toRadixString(16).padLeft(8, '0');
    return '$timestamp-$randomHex';
  }

  /// Generates a deterministic 3-word alias from entropy using BIP39 wordlist
  /// The alias is generated by using the entropy bytes to select words
  /// [entropy] - The entropy bytes (typically from a SHA-256 hash)
  /// [offset] - Byte offset into the entropy (0, 6, 12, 18, etc.) to use different parts
  String _generateRandomDanaAddress(
      {required String spAddress, required int offset}) {
    final entropy = _generateEntropyFromAddress(spAddress);

    final wordlist = getEnglishWordlist();
    final wordlistSize = wordlist.length;

    // Ensure we have enough bytes for the offset
    if (offset + 6 > entropy.length) {
      // If offset is too large, wrap around using modulo
      offset = offset % (entropy.length - 5);
    }

    // Use different parts of the entropy to select 2 words and 1 number
    // This ensures deterministic selection while avoiding collisions
    final word1Index =
        (entropy[offset] << 8 | entropy[offset + 1]) % wordlistSize;
    final word2Index =
        (entropy[offset + 2] << 8 | entropy[offset + 3]) % wordlistSize;
    final numericValue =
        (entropy[offset + 4] << 8 | entropy[offset + 5]) % 1000;

    return '${wordlist[word1Index]}-${wordlist[word2Index]}-$numericValue';
  }

  /// Generates entropy (SHA-256 hash) from an address
  List<int> _generateEntropyFromAddress(String spAddress) {
    final bytes = utf8.encode(spAddress);
    final hash = sha256.convert(bytes);
    return hash.bytes;
  }

  /// Generate an available dana address by trying different username candidates
  /// Returns the first available username found within maxRetries attempts, or null if all are taken
  Future<String?> generateAvailableDanaAddress({
    required String spAddress,
    required int maxRetries,
  }) async {
    for (int attempt = 0; attempt < maxRetries; attempt++) {
      final username = _generateRandomDanaAddress(
        spAddress: spAddress,
        offset:
            attempt * 6, // Each attempt uses 6 bytes (2 bytes per word/number)
      );
      final isAvailable = await isDanaUsernameAvailable(username);
      if (isAvailable) {
        return username;
      }
    }
    return null;
  }

  /// Creates a dana address by calling the external name_server
  ///
  /// [danaAddress] - The address to register.
  /// [requestId] - The unique id for this request, can be useful for tracking requests.
  ///
  /// Returns [DanaAddressCreationResponse] with the created address or error details
  Future<Bip353Address> registerUser({
    required String username,
    required String spAddress,
  }) async {
    final requestId = _generateUniqueId();
    final domain = await danaAddressDomain;
    final Bip353Address danaAddress;

    // We try to resolve the address first to see if it already exists
    try {
      danaAddress = Bip353Address(username: username, domain: domain);
      final resolvedSpAddress =
          await Bip353Resolver.resolve(danaAddress, network);
      if (resolvedSpAddress == null) {
        // Address not registered yet, proceed with registration
        Logger().i(
            'Address $username@$domain not found, proceeding with registration');
      } else if (resolvedSpAddress == spAddress) {
        // If we find our address, return success there's nothing more to do
        return danaAddress;
      } else if (resolvedSpAddress != spAddress) {
        // If we find another address, return error, user must try with a different username
        throw Exception("Dana address already in use");
      }
    } catch (e) {
      // Network or parsing error - we'll let name server try and if it exists it will return an error
      Logger().e('Failed to resolve address for user $username: $e');
      rethrow;
    }

    return await nameServerRepository.registerDanaAddress(
        danaAddress: danaAddress, spAddress: spAddress, requestId: requestId);
  }

  /// Looks up dana addresses associated with a silent payment address.
  /// Also verifies if the returned Dana address by doing a DNS query
  ///
  /// [spAddress] - The Silent Payment address to lookup
  ///
  /// Returns the first valid dana address that is found.
  /// Returns a list of dana addresses in the format `user_name@danawallet.app`
  /// Returns an empty list if no addresses are found
  /// Throws an exception for network errors, invalid responses, or malformed data
  Future<Bip353Address?> lookupDanaAddress(String spAddress) async {
    if (spAddress.isEmpty) {
      throw ArgumentError("Silent payment address cannot be empty");
    }

    final requestId = _generateUniqueId();
    final addresses =
        await nameServerRepository.lookupDanaAddresses(spAddress, requestId);

    Logger().i('Found ${addresses.length} dana address(es) for SP address');

    for (var candidate in addresses) {
      if (await Bip353Resolver.verifyAddress(candidate, spAddress, network)) {
        // we just return the first valid candidate
        return candidate;
      } else {
        Logger()
            .w("Name server returned an address that doesn't resolve to ours");
      }
    }
    return null;
  }

  /// Check if a dana address is available for registration
  /// Returns true if the dana address is not taken, false otherwise
  Future<bool> isDanaUsernameAvailable(String username) async {
    try {
      final domain = await danaAddressDomain;
      final parsed = Bip353Address(username: username, domain: domain);
      return await Bip353Resolver.isBip353AddressPresent(parsed, network);
    } catch (e) {
      // If we can't resolve due to network error, assume it's taken to be safe
      Logger().e('Error checking address availability: $e');
      return false;
    }
  }

  /// Searches for dana addresses by prefix
  ///
  /// [prefix] - The prefix to search for (e.g., "alice" to find "alice@domain.com")
  ///
  /// Returns [PrefixSearchResponse] with matching dana addresses
  /// Throws an exception for network errors, invalid responses, or malformed data
  Future<List<Bip353Address>> searchPrefix(String prefix) async {
    if (prefix.isEmpty) {
      throw ArgumentError("Prefix cannot be empty");
    }

    try {
      final requestId = _generateUniqueId();
      final response = await nameServerRepository.searchDanaAddressesWithPrefix(
          prefix, requestId);
      return response.danaAddresses;
    } catch (e) {
      Logger().e('Prefix search request failed for prefix "$prefix": $e');
      throw Exception('Prefix search request failed: $e');
    }
  }
}
