// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.3.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'structs.dart';

ApiSetupResult setupWallet({required ApiSetupWalletArgs setupArgs}) =>
    RustLib.instance.api.crateApiWalletSetupWallet(setupArgs: setupArgs);

Future<void> scanToTip(
        {required String blindbitUrl,
        required int lastScan,
        required BigInt dustLimit,
        required String encodedWallet,
        required String encodedHistory,
        required String encodedOwnedOutputs}) =>
    RustLib.instance.api.crateApiWalletScanToTip(
        blindbitUrl: blindbitUrl,
        lastScan: lastScan,
        dustLimit: dustLimit,
        encodedWallet: encodedWallet,
        encodedHistory: encodedHistory,
        encodedOwnedOutputs: encodedOwnedOutputs);

void interruptScanning() =>
    RustLib.instance.api.crateApiWalletInterruptScanning();

ApiWalletStatus getWalletInfo({required String encodedWallet}) =>
    RustLib.instance.api
        .crateApiWalletGetWalletInfo(encodedWallet: encodedWallet);

/// Only call this when we expect this value to be present
int getWalletLastScan({required String encodedWallet}) => RustLib.instance.api
    .crateApiWalletGetWalletLastScan(encodedWallet: encodedWallet);

/// Only call this when we expect this value to be present
String getWalletTxHistory({required String encodedWallet}) =>
    RustLib.instance.api
        .crateApiWalletGetWalletTxHistory(encodedWallet: encodedWallet);

/// Only call this when we expect this value to be present
String getWalletOwnedOutputs({required String encodedWallet}) =>
    RustLib.instance.api
        .crateApiWalletGetWalletOwnedOutputs(encodedWallet: encodedWallet);

ApiSilentPaymentUnsignedTransaction createNewTransaction(
        {required String encodedWallet,
        required Map<String, ApiOwnedOutput> apiOutputs,
        required List<ApiRecipient> apiRecipients,
        required double feerate,
        required String network}) =>
    RustLib.instance.api.crateApiWalletCreateNewTransaction(
        encodedWallet: encodedWallet,
        apiOutputs: apiOutputs,
        apiRecipients: apiRecipients,
        feerate: feerate,
        network: network);

ApiSilentPaymentUnsignedTransaction createDrainTransaction(
        {required String encodedWallet,
        required Map<String, ApiOwnedOutput> apiOutputs,
        required String wipeAddress,
        required double feerate,
        required String network}) =>
    RustLib.instance.api.crateApiWalletCreateDrainTransaction(
        encodedWallet: encodedWallet,
        apiOutputs: apiOutputs,
        wipeAddress: wipeAddress,
        feerate: feerate,
        network: network);

ApiSilentPaymentUnsignedTransaction finalizeTransaction(
        {required ApiSilentPaymentUnsignedTransaction unsignedTransaction}) =>
    RustLib.instance.api.crateApiWalletFinalizeTransaction(
        unsignedTransaction: unsignedTransaction);

String signTransaction(
        {required String encodedWallet,
        required ApiSilentPaymentUnsignedTransaction unsignedTransaction}) =>
    RustLib.instance.api.crateApiWalletSignTransaction(
        encodedWallet: encodedWallet, unsignedTransaction: unsignedTransaction);

Future<String> broadcastTx({required String tx, required String network}) =>
    RustLib.instance.api.crateApiWalletBroadcastTx(tx: tx, network: network);
