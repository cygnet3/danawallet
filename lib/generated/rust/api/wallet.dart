// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.3.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'structs.dart';

ApiSetupResult setupWallet({required ApiSetupWalletArgs setupArgs}) =>
    RustLib.instance.api.crateApiWalletSetupWallet(setupArgs: setupArgs);

/// Change wallet birthday
/// Reset the output list and last_scan
String changeBirthday({required String encodedWallet, required int birthday}) =>
    RustLib.instance.api.crateApiWalletChangeBirthday(
        encodedWallet: encodedWallet, birthday: birthday);

/// Reset the last_scan of the wallet to its birthday, removing all outpoints
String resetWallet({required String encodedWallet}) => RustLib.instance.api
    .crateApiWalletResetWallet(encodedWallet: encodedWallet);

Future<void> scanToTip(
        {required String blindbitUrl,
        required BigInt dustLimit,
        required String encodedWallet}) =>
    RustLib.instance.api.crateApiWalletScanToTip(
        blindbitUrl: blindbitUrl,
        dustLimit: dustLimit,
        encodedWallet: encodedWallet);

void interruptScanning() =>
    RustLib.instance.api.crateApiWalletInterruptScanning();

ApiWalletStatus getWalletInfo({required String encodedWallet}) =>
    RustLib.instance.api
        .crateApiWalletGetWalletInfo(encodedWallet: encodedWallet);

String markOutpointsSpent(
        {required String encodedWallet,
        required String spentBy,
        required List<String> spent}) =>
    RustLib.instance.api.crateApiWalletMarkOutpointsSpent(
        encodedWallet: encodedWallet, spentBy: spentBy, spent: spent);

String addOutgoingTxToHistory(
        {required String encodedWallet,
        required String txid,
        required List<String> spentOutpoints,
        required List<ApiRecipient> recipients,
        required Amount change}) =>
    RustLib.instance.api.crateApiWalletAddOutgoingTxToHistory(
        encodedWallet: encodedWallet,
        txid: txid,
        spentOutpoints: spentOutpoints,
        recipients: recipients,
        change: change);

ApiSilentPaymentUnsignedTransaction createNewTransaction(
        {required String encodedWallet,
        required Map<String, ApiOwnedOutput> apiOutputs,
        required List<ApiRecipient> apiRecipients,
        required double feerate,
        required String network}) =>
    RustLib.instance.api.crateApiWalletCreateNewTransaction(
        encodedWallet: encodedWallet,
        apiOutputs: apiOutputs,
        apiRecipients: apiRecipients,
        feerate: feerate,
        network: network);

ApiSilentPaymentUnsignedTransaction createDrainTransaction(
        {required String encodedWallet,
        required Map<String, ApiOwnedOutput> apiOutputs,
        required String wipeAddress,
        required double feerate,
        required String network}) =>
    RustLib.instance.api.crateApiWalletCreateDrainTransaction(
        encodedWallet: encodedWallet,
        apiOutputs: apiOutputs,
        wipeAddress: wipeAddress,
        feerate: feerate,
        network: network);

ApiSilentPaymentUnsignedTransaction finalizeTransaction(
        {required ApiSilentPaymentUnsignedTransaction unsignedTransaction}) =>
    RustLib.instance.api.crateApiWalletFinalizeTransaction(
        unsignedTransaction: unsignedTransaction);

String signTransaction(
        {required String encodedWallet,
        required ApiSilentPaymentUnsignedTransaction unsignedTransaction}) =>
    RustLib.instance.api.crateApiWalletSignTransaction(
        encodedWallet: encodedWallet, unsignedTransaction: unsignedTransaction);

Future<String> broadcastTx({required String tx, required String network}) =>
    RustLib.instance.api.crateApiWalletBroadcastTx(tx: tx, network: network);
