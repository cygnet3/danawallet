// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.3.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'structs.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

class Amount {
  final BigInt field0;

  const Amount({
    required this.field0,
  });

  BigInt toInt() => RustLib.instance.api.crateApiStructsAmountToInt(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Amount &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class ApiSetupResult {
  final String walletBlob;
  final String? mnemonic;

  const ApiSetupResult({
    required this.walletBlob,
    this.mnemonic,
  });

  @override
  int get hashCode => walletBlob.hashCode ^ mnemonic.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiSetupResult &&
          runtimeType == other.runtimeType &&
          walletBlob == other.walletBlob &&
          mnemonic == other.mnemonic;
}

class ApiSetupWalletArgs {
  final ApiSetupWalletType setupType;
  final int birthday;
  final String network;

  const ApiSetupWalletArgs({
    required this.setupType,
    required this.birthday,
    required this.network,
  });

  @override
  int get hashCode => setupType.hashCode ^ birthday.hashCode ^ network.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiSetupWalletArgs &&
          runtimeType == other.runtimeType &&
          setupType == other.setupType &&
          birthday == other.birthday &&
          network == other.network;
}

@freezed
sealed class ApiSetupWalletType with _$ApiSetupWalletType {
  const ApiSetupWalletType._();

  const factory ApiSetupWalletType.newWallet() = ApiSetupWalletType_NewWallet;
  const factory ApiSetupWalletType.mnemonic(
    String field0,
  ) = ApiSetupWalletType_Mnemonic;
  const factory ApiSetupWalletType.full(
    String field0,
    String field1,
  ) = ApiSetupWalletType_Full;
  const factory ApiSetupWalletType.watchOnly(
    String field0,
    String field1,
  ) = ApiSetupWalletType_WatchOnly;
}

@freezed
sealed class OutputSpendStatus with _$OutputSpendStatus {
  const OutputSpendStatus._();

  const factory OutputSpendStatus.unspent() = OutputSpendStatus_Unspent;
  const factory OutputSpendStatus.spent(
    String field0,
  ) = OutputSpendStatus_Spent;
  const factory OutputSpendStatus.mined(
    String field0,
  ) = OutputSpendStatus_Mined;
}

class OwnedOutput {
  final int blockheight;
  final U8Array32 tweak;
  final Amount amount;
  final String script;
  final String? label;
  final OutputSpendStatus spendStatus;

  const OwnedOutput({
    required this.blockheight,
    required this.tweak,
    required this.amount,
    required this.script,
    this.label,
    required this.spendStatus,
  });

  @override
  int get hashCode =>
      blockheight.hashCode ^
      tweak.hashCode ^
      amount.hashCode ^
      script.hashCode ^
      label.hashCode ^
      spendStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OwnedOutput &&
          runtimeType == other.runtimeType &&
          blockheight == other.blockheight &&
          tweak == other.tweak &&
          amount == other.amount &&
          script == other.script &&
          label == other.label &&
          spendStatus == other.spendStatus;
}

class Recipient {
  final String address;
  final Amount amount;
  final int nbOutputs;

  const Recipient({
    required this.address,
    required this.amount,
    required this.nbOutputs,
  });

  @override
  int get hashCode => address.hashCode ^ amount.hashCode ^ nbOutputs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Recipient &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          amount == other.amount &&
          nbOutputs == other.nbOutputs;
}

@freezed
sealed class RecordedTransaction with _$RecordedTransaction {
  const RecordedTransaction._();

  const factory RecordedTransaction.incoming(
    RecordedTransactionIncoming field0,
  ) = RecordedTransaction_Incoming;
  const factory RecordedTransaction.outgoing(
    RecordedTransactionOutgoing field0,
  ) = RecordedTransaction_Outgoing;
}

class RecordedTransactionIncoming {
  final String txid;
  final Amount amount;
  final int? confirmedAt;

  const RecordedTransactionIncoming({
    required this.txid,
    required this.amount,
    this.confirmedAt,
  });

  String toString() =>
      RustLib.instance.api.crateApiStructsRecordedTransactionIncomingToString(
        that: this,
      );

  @override
  int get hashCode => txid.hashCode ^ amount.hashCode ^ confirmedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RecordedTransactionIncoming &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          amount == other.amount &&
          confirmedAt == other.confirmedAt;
}

class RecordedTransactionOutgoing {
  final String txid;
  final List<String> spentOutpoints;
  final List<Recipient> recipients;
  final int? confirmedAt;
  final Amount change;

  const RecordedTransactionOutgoing({
    required this.txid,
    required this.spentOutpoints,
    required this.recipients,
    this.confirmedAt,
    required this.change,
  });

  String toString() =>
      RustLib.instance.api.crateApiStructsRecordedTransactionOutgoingToString(
        that: this,
      );

  @override
  int get hashCode =>
      txid.hashCode ^
      spentOutpoints.hashCode ^
      recipients.hashCode ^
      confirmedAt.hashCode ^
      change.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RecordedTransactionOutgoing &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          spentOutpoints == other.spentOutpoints &&
          recipients == other.recipients &&
          confirmedAt == other.confirmedAt &&
          change == other.change;
}

class WalletStatus {
  final String address;
  final String network;
  final BigInt balance;
  final int birthday;
  final int lastScan;
  final Map<String, OwnedOutput> outputs;
  final List<RecordedTransaction> txHistory;

  const WalletStatus({
    required this.address,
    required this.network,
    required this.balance,
    required this.birthday,
    required this.lastScan,
    required this.outputs,
    required this.txHistory,
  });

  @override
  int get hashCode =>
      address.hashCode ^
      network.hashCode ^
      balance.hashCode ^
      birthday.hashCode ^
      lastScan.hashCode ^
      outputs.hashCode ^
      txHistory.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletStatus &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          network == other.network &&
          balance == other.balance &&
          birthday == other.birthday &&
          lastScan == other.lastScan &&
          outputs == other.outputs &&
          txHistory == other.txHistory;
}
