// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'structs.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `try_from`, `try_from`, `try_from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiNetwork>>
abstract class ApiNetwork implements RustOpaqueInterface {
  String toString();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiSilentPaymentAddress>>
abstract class ApiSilentPaymentAddress implements RustOpaqueInterface {
  String get mPubkey;

  ApiNetwork get network;

  String get scanPubkey;

  String get stringRepresentation;

  int get version;

  set mPubkey(String mPubkey);

  set network(ApiNetwork network);

  set scanPubkey(String scanPubkey);

  set stringRepresentation(String stringRepresentation);

  set version(int version);

  static ApiSilentPaymentAddress fromJsonString({required String json}) =>
      RustLib.instance.api
          .crateApiStructsApiSilentPaymentAddressFromJsonString(json: json);
}

class ApiAmount {
  final BigInt field0;

  const ApiAmount({
    required this.field0,
  });

  static Future<ApiAmount> default_() =>
      RustLib.instance.api.crateApiStructsApiAmountDefault();

  String displayBtc() =>
      RustLib.instance.api.crateApiStructsApiAmountDisplayBtc(
        that: this,
      );

  String displaySats() =>
      RustLib.instance.api.crateApiStructsApiAmountDisplaySats(
        that: this,
      );

  BigInt toInt() => RustLib.instance.api.crateApiStructsApiAmountToInt(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiAmount &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

@freezed
sealed class ApiOutputSpendStatus with _$ApiOutputSpendStatus {
  const ApiOutputSpendStatus._();

  const factory ApiOutputSpendStatus.unspent() = ApiOutputSpendStatus_Unspent;
  const factory ApiOutputSpendStatus.spent(
    String field0,
  ) = ApiOutputSpendStatus_Spent;
  const factory ApiOutputSpendStatus.mined(
    String field0,
  ) = ApiOutputSpendStatus_Mined;
}

class ApiOwnedOutput {
  final int blockheight;
  final U8Array32 tweak;
  final ApiAmount amount;
  final String script;
  final String? label;
  final ApiOutputSpendStatus spendStatus;

  const ApiOwnedOutput({
    required this.blockheight,
    required this.tweak,
    required this.amount,
    required this.script,
    this.label,
    required this.spendStatus,
  });

  @override
  int get hashCode =>
      blockheight.hashCode ^
      tweak.hashCode ^
      amount.hashCode ^
      script.hashCode ^
      label.hashCode ^
      spendStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiOwnedOutput &&
          runtimeType == other.runtimeType &&
          blockheight == other.blockheight &&
          tweak == other.tweak &&
          amount == other.amount &&
          script == other.script &&
          label == other.label &&
          spendStatus == other.spendStatus;
}

class ApiRecipient {
  final String address;
  final ApiAmount amount;

  const ApiRecipient({
    required this.address,
    required this.amount,
  });

  @override
  int get hashCode => address.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiRecipient &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          amount == other.amount;
}

@freezed
sealed class ApiRecordedTransaction with _$ApiRecordedTransaction {
  const ApiRecordedTransaction._();

  const factory ApiRecordedTransaction.incoming(
    ApiRecordedTransactionIncoming field0,
  ) = ApiRecordedTransaction_Incoming;
  const factory ApiRecordedTransaction.outgoing(
    ApiRecordedTransactionOutgoing field0,
  ) = ApiRecordedTransaction_Outgoing;
}

class ApiRecordedTransactionIncoming {
  final String txid;
  final ApiAmount amount;
  final int? confirmedAt;

  const ApiRecordedTransactionIncoming({
    required this.txid,
    required this.amount,
    this.confirmedAt,
  });

  String toString() => RustLib.instance.api
          .crateApiStructsApiRecordedTransactionIncomingToString(
        that: this,
      );

  @override
  int get hashCode => txid.hashCode ^ amount.hashCode ^ confirmedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiRecordedTransactionIncoming &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          amount == other.amount &&
          confirmedAt == other.confirmedAt;
}

class ApiRecordedTransactionOutgoing {
  final String txid;
  final List<String> spentOutpoints;
  final List<ApiRecipient> recipients;
  final int? confirmedAt;
  final ApiAmount change;
  final ApiAmount fee;

  const ApiRecordedTransactionOutgoing({
    required this.txid,
    required this.spentOutpoints,
    required this.recipients,
    this.confirmedAt,
    required this.change,
    required this.fee,
  });

  String toString() => RustLib.instance.api
          .crateApiStructsApiRecordedTransactionOutgoingToString(
        that: this,
      );

  ApiAmount totalOutgoing() => RustLib.instance.api
          .crateApiStructsApiRecordedTransactionOutgoingTotalOutgoing(
        that: this,
      );

  @override
  int get hashCode =>
      txid.hashCode ^
      spentOutpoints.hashCode ^
      recipients.hashCode ^
      confirmedAt.hashCode ^
      change.hashCode ^
      fee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiRecordedTransactionOutgoing &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          spentOutpoints == other.spentOutpoints &&
          recipients == other.recipients &&
          confirmedAt == other.confirmedAt &&
          change == other.change &&
          fee == other.fee;
}

class ApiSilentPaymentUnsignedTransaction {
  final List<(String, ApiOwnedOutput)> selectedUtxos;
  final List<ApiRecipient> recipients;
  final U8Array32 partialSecret;
  final String? unsignedTx;
  final String network;

  const ApiSilentPaymentUnsignedTransaction({
    required this.selectedUtxos,
    required this.recipients,
    required this.partialSecret,
    this.unsignedTx,
    required this.network,
  });

  ApiAmount getChangeAmount({required String changeAddress}) => RustLib
      .instance.api
      .crateApiStructsApiSilentPaymentUnsignedTransactionGetChangeAmount(
          that: this, changeAddress: changeAddress);

  ApiAmount getFeeAmount() => RustLib.instance.api
          .crateApiStructsApiSilentPaymentUnsignedTransactionGetFeeAmount(
        that: this,
      );

  List<ApiRecipient> getRecipients({required String changeAddress}) =>
      RustLib.instance.api
          .crateApiStructsApiSilentPaymentUnsignedTransactionGetRecipients(
              that: this, changeAddress: changeAddress);

  ApiAmount getSendAmount({required String changeAddress}) =>
      RustLib.instance.api
          .crateApiStructsApiSilentPaymentUnsignedTransactionGetSendAmount(
              that: this, changeAddress: changeAddress);

  @override
  int get hashCode =>
      selectedUtxos.hashCode ^
      recipients.hashCode ^
      partialSecret.hashCode ^
      unsignedTx.hashCode ^
      network.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiSilentPaymentUnsignedTransaction &&
          runtimeType == other.runtimeType &&
          selectedUtxos == other.selectedUtxos &&
          recipients == other.recipients &&
          partialSecret == other.partialSecret &&
          unsignedTx == other.unsignedTx &&
          network == other.network;
}
