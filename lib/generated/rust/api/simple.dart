// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../logger.dart';
import '../stream.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'simple.freezed.dart';

// The functions `fmt`, `clone`, `eq`, `from`, `from`, `fmt`, `clone`, `eq`, `from`, `from`, `fmt`, `clone`, `eq`, `from`, `from`, `fmt`, `clone`, `eq`, `from`, `from` are not `pub`, thus are ignored.

Stream<LogEntry> createLogStream(
        {required LogLevel level, required bool logDependencies}) =>
    RustLib.instance.api.crateApiSimpleCreateLogStream(
        level: level, logDependencies: logDependencies);

Stream<ScanProgress> createScanProgressStream() =>
    RustLib.instance.api.crateApiSimpleCreateScanProgressStream();

Stream<BigInt> createAmountStream() =>
    RustLib.instance.api.crateApiSimpleCreateAmountStream();

Future<String> setup(
        {required String label,
        String? mnemonic,
        String? scanKey,
        String? spendKey,
        required int birthday,
        required String network}) =>
    RustLib.instance.api.crateApiSimpleSetup(
        label: label,
        mnemonic: mnemonic,
        scanKey: scanKey,
        spendKey: spendKey,
        birthday: birthday,
        network: network);

/// Change wallet birthday
/// Reset the output list and last_scan
String changeBirthday({required String encodedWallet, required int birthday}) =>
    RustLib.instance.api.crateApiSimpleChangeBirthday(
        encodedWallet: encodedWallet, birthday: birthday);

/// Reset the last_scan of the wallet to its birthday, removing all outpoints
String resetWallet({required String encodedWallet}) => RustLib.instance.api
    .crateApiSimpleResetWallet(encodedWallet: encodedWallet);

Future<int> syncBlockchain() =>
    RustLib.instance.api.crateApiSimpleSyncBlockchain();

Future<String> scanToTip({required String encodedWallet}) =>
    RustLib.instance.api.crateApiSimpleScanToTip(encodedWallet: encodedWallet);

WalletStatus getWalletInfo({required String encodedWallet}) =>
    RustLib.instance.api
        .crateApiSimpleGetWalletInfo(encodedWallet: encodedWallet);

String createNewPsbt(
        {required String encodedWallet,
        required Map<String, OwnedOutput> inputs,
        required List<Recipient> recipients}) =>
    RustLib.instance.api.crateApiSimpleCreateNewPsbt(
        encodedWallet: encodedWallet, inputs: inputs, recipients: recipients);

String addFeeForFeeRate(
        {required String psbt, required int feeRate, required String payer}) =>
    RustLib.instance.api.crateApiSimpleAddFeeForFeeRate(
        psbt: psbt, feeRate: feeRate, payer: payer);

String fillSpOutputs({required String encodedWallet, required String psbt}) =>
    RustLib.instance.api
        .crateApiSimpleFillSpOutputs(encodedWallet: encodedWallet, psbt: psbt);

String signPsbt(
        {required String encodedWallet,
        required String psbt,
        required bool finalize}) =>
    RustLib.instance.api.crateApiSimpleSignPsbt(
        encodedWallet: encodedWallet, psbt: psbt, finalize: finalize);

String extractTxFromPsbt({required String psbt}) =>
    RustLib.instance.api.crateApiSimpleExtractTxFromPsbt(psbt: psbt);

String broadcastTx({required String tx}) =>
    RustLib.instance.api.crateApiSimpleBroadcastTx(tx: tx);

String markOutpointsSpent(
        {required String encodedWallet,
        required String spentBy,
        required List<String> spent}) =>
    RustLib.instance.api.crateApiSimpleMarkOutpointsSpent(
        encodedWallet: encodedWallet, spentBy: spentBy, spent: spent);

String? showMnemonic({required String encodedWallet}) => RustLib.instance.api
    .crateApiSimpleShowMnemonic(encodedWallet: encodedWallet);

class Amount {
  final BigInt field0;

  const Amount({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Amount &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

@freezed
sealed class OutputSpendStatus with _$OutputSpendStatus {
  const OutputSpendStatus._();

  const factory OutputSpendStatus.unspent() = OutputSpendStatus_Unspent;
  const factory OutputSpendStatus.spent(
    String field0,
  ) = OutputSpendStatus_Spent;
  const factory OutputSpendStatus.mined(
    String field0,
  ) = OutputSpendStatus_Mined;
}

class OwnedOutput {
  final int blockheight;
  final String tweak;
  final Amount amount;
  final String script;
  final String? label;
  final OutputSpendStatus spendStatus;

  const OwnedOutput({
    required this.blockheight,
    required this.tweak,
    required this.amount,
    required this.script,
    this.label,
    required this.spendStatus,
  });

  @override
  int get hashCode =>
      blockheight.hashCode ^
      tweak.hashCode ^
      amount.hashCode ^
      script.hashCode ^
      label.hashCode ^
      spendStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OwnedOutput &&
          runtimeType == other.runtimeType &&
          blockheight == other.blockheight &&
          tweak == other.tweak &&
          amount == other.amount &&
          script == other.script &&
          label == other.label &&
          spendStatus == other.spendStatus;
}

class Recipient {
  final String address;
  final Amount amount;
  final int nbOutputs;

  const Recipient({
    required this.address,
    required this.amount,
    required this.nbOutputs,
  });

  @override
  int get hashCode => address.hashCode ^ amount.hashCode ^ nbOutputs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Recipient &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          amount == other.amount &&
          nbOutputs == other.nbOutputs;
}

class WalletStatus {
  final String address;
  final BigInt balance;
  final int birthday;
  final int lastScan;
  final Map<String, OwnedOutput> outputs;

  const WalletStatus({
    required this.address,
    required this.balance,
    required this.birthday,
    required this.lastScan,
    required this.outputs,
  });

  @override
  int get hashCode =>
      address.hashCode ^
      balance.hashCode ^
      birthday.hashCode ^
      lastScan.hashCode ^
      outputs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletStatus &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          balance == other.balance &&
          birthday == other.birthday &&
          lastScan == other.lastScan &&
          outputs == other.outputs;
}
