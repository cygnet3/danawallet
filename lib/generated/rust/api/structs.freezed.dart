// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'structs.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$OutputSpendStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OutputSpendStatusCopyWith<$Res> {
  factory $OutputSpendStatusCopyWith(
          OutputSpendStatus value, $Res Function(OutputSpendStatus) then) =
      _$OutputSpendStatusCopyWithImpl<$Res, OutputSpendStatus>;
}

/// @nodoc
class _$OutputSpendStatusCopyWithImpl<$Res, $Val extends OutputSpendStatus>
    implements $OutputSpendStatusCopyWith<$Res> {
  _$OutputSpendStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$OutputSpendStatus_UnspentImplCopyWith<$Res> {
  factory _$$OutputSpendStatus_UnspentImplCopyWith(
          _$OutputSpendStatus_UnspentImpl value,
          $Res Function(_$OutputSpendStatus_UnspentImpl) then) =
      __$$OutputSpendStatus_UnspentImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OutputSpendStatus_UnspentImplCopyWithImpl<$Res>
    extends _$OutputSpendStatusCopyWithImpl<$Res,
        _$OutputSpendStatus_UnspentImpl>
    implements _$$OutputSpendStatus_UnspentImplCopyWith<$Res> {
  __$$OutputSpendStatus_UnspentImplCopyWithImpl(
      _$OutputSpendStatus_UnspentImpl _value,
      $Res Function(_$OutputSpendStatus_UnspentImpl) _then)
      : super(_value, _then);

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$OutputSpendStatus_UnspentImpl extends OutputSpendStatus_Unspent {
  const _$OutputSpendStatus_UnspentImpl() : super._();

  @override
  String toString() {
    return 'OutputSpendStatus.unspent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OutputSpendStatus_UnspentImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return unspent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return unspent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (unspent != null) {
      return unspent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) {
    return unspent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) {
    return unspent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (unspent != null) {
      return unspent(this);
    }
    return orElse();
  }
}

abstract class OutputSpendStatus_Unspent extends OutputSpendStatus {
  const factory OutputSpendStatus_Unspent() = _$OutputSpendStatus_UnspentImpl;
  const OutputSpendStatus_Unspent._() : super._();
}

/// @nodoc
abstract class _$$OutputSpendStatus_SpentImplCopyWith<$Res> {
  factory _$$OutputSpendStatus_SpentImplCopyWith(
          _$OutputSpendStatus_SpentImpl value,
          $Res Function(_$OutputSpendStatus_SpentImpl) then) =
      __$$OutputSpendStatus_SpentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$OutputSpendStatus_SpentImplCopyWithImpl<$Res>
    extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_SpentImpl>
    implements _$$OutputSpendStatus_SpentImplCopyWith<$Res> {
  __$$OutputSpendStatus_SpentImplCopyWithImpl(
      _$OutputSpendStatus_SpentImpl _value,
      $Res Function(_$OutputSpendStatus_SpentImpl) _then)
      : super(_value, _then);

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$OutputSpendStatus_SpentImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$OutputSpendStatus_SpentImpl extends OutputSpendStatus_Spent {
  const _$OutputSpendStatus_SpentImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'OutputSpendStatus.spent(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OutputSpendStatus_SpentImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OutputSpendStatus_SpentImplCopyWith<_$OutputSpendStatus_SpentImpl>
      get copyWith => __$$OutputSpendStatus_SpentImplCopyWithImpl<
          _$OutputSpendStatus_SpentImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return spent(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return spent?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (spent != null) {
      return spent(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) {
    return spent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) {
    return spent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (spent != null) {
      return spent(this);
    }
    return orElse();
  }
}

abstract class OutputSpendStatus_Spent extends OutputSpendStatus {
  const factory OutputSpendStatus_Spent(final String field0) =
      _$OutputSpendStatus_SpentImpl;
  const OutputSpendStatus_Spent._() : super._();

  String get field0;

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OutputSpendStatus_SpentImplCopyWith<_$OutputSpendStatus_SpentImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OutputSpendStatus_MinedImplCopyWith<$Res> {
  factory _$$OutputSpendStatus_MinedImplCopyWith(
          _$OutputSpendStatus_MinedImpl value,
          $Res Function(_$OutputSpendStatus_MinedImpl) then) =
      __$$OutputSpendStatus_MinedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$OutputSpendStatus_MinedImplCopyWithImpl<$Res>
    extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_MinedImpl>
    implements _$$OutputSpendStatus_MinedImplCopyWith<$Res> {
  __$$OutputSpendStatus_MinedImplCopyWithImpl(
      _$OutputSpendStatus_MinedImpl _value,
      $Res Function(_$OutputSpendStatus_MinedImpl) _then)
      : super(_value, _then);

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$OutputSpendStatus_MinedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$OutputSpendStatus_MinedImpl extends OutputSpendStatus_Mined {
  const _$OutputSpendStatus_MinedImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'OutputSpendStatus.mined(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OutputSpendStatus_MinedImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OutputSpendStatus_MinedImplCopyWith<_$OutputSpendStatus_MinedImpl>
      get copyWith => __$$OutputSpendStatus_MinedImplCopyWithImpl<
          _$OutputSpendStatus_MinedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return mined(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return mined?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (mined != null) {
      return mined(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OutputSpendStatus_Unspent value) unspent,
    required TResult Function(OutputSpendStatus_Spent value) spent,
    required TResult Function(OutputSpendStatus_Mined value) mined,
  }) {
    return mined(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OutputSpendStatus_Unspent value)? unspent,
    TResult? Function(OutputSpendStatus_Spent value)? spent,
    TResult? Function(OutputSpendStatus_Mined value)? mined,
  }) {
    return mined?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OutputSpendStatus_Unspent value)? unspent,
    TResult Function(OutputSpendStatus_Spent value)? spent,
    TResult Function(OutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (mined != null) {
      return mined(this);
    }
    return orElse();
  }
}

abstract class OutputSpendStatus_Mined extends OutputSpendStatus {
  const factory OutputSpendStatus_Mined(final String field0) =
      _$OutputSpendStatus_MinedImpl;
  const OutputSpendStatus_Mined._() : super._();

  String get field0;

  /// Create a copy of OutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OutputSpendStatus_MinedImplCopyWith<_$OutputSpendStatus_MinedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RecordedTransaction {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecordedTransactionIncoming field0) incoming,
    required TResult Function(RecordedTransactionOutgoing field0) outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecordedTransactionIncoming field0)? incoming,
    TResult? Function(RecordedTransactionOutgoing field0)? outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecordedTransactionIncoming field0)? incoming,
    TResult Function(RecordedTransactionOutgoing field0)? outgoing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RecordedTransaction_Incoming value) incoming,
    required TResult Function(RecordedTransaction_Outgoing value) outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RecordedTransaction_Incoming value)? incoming,
    TResult? Function(RecordedTransaction_Outgoing value)? outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RecordedTransaction_Incoming value)? incoming,
    TResult Function(RecordedTransaction_Outgoing value)? outgoing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecordedTransactionCopyWith<$Res> {
  factory $RecordedTransactionCopyWith(
          RecordedTransaction value, $Res Function(RecordedTransaction) then) =
      _$RecordedTransactionCopyWithImpl<$Res, RecordedTransaction>;
}

/// @nodoc
class _$RecordedTransactionCopyWithImpl<$Res, $Val extends RecordedTransaction>
    implements $RecordedTransactionCopyWith<$Res> {
  _$RecordedTransactionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$RecordedTransaction_IncomingImplCopyWith<$Res> {
  factory _$$RecordedTransaction_IncomingImplCopyWith(
          _$RecordedTransaction_IncomingImpl value,
          $Res Function(_$RecordedTransaction_IncomingImpl) then) =
      __$$RecordedTransaction_IncomingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecordedTransactionIncoming field0});
}

/// @nodoc
class __$$RecordedTransaction_IncomingImplCopyWithImpl<$Res>
    extends _$RecordedTransactionCopyWithImpl<$Res,
        _$RecordedTransaction_IncomingImpl>
    implements _$$RecordedTransaction_IncomingImplCopyWith<$Res> {
  __$$RecordedTransaction_IncomingImplCopyWithImpl(
      _$RecordedTransaction_IncomingImpl _value,
      $Res Function(_$RecordedTransaction_IncomingImpl) _then)
      : super(_value, _then);

  /// Create a copy of RecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RecordedTransaction_IncomingImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as RecordedTransactionIncoming,
    ));
  }
}

/// @nodoc

class _$RecordedTransaction_IncomingImpl extends RecordedTransaction_Incoming {
  const _$RecordedTransaction_IncomingImpl(this.field0) : super._();

  @override
  final RecordedTransactionIncoming field0;

  @override
  String toString() {
    return 'RecordedTransaction.incoming(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecordedTransaction_IncomingImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RecordedTransaction_IncomingImplCopyWith<
          _$RecordedTransaction_IncomingImpl>
      get copyWith => __$$RecordedTransaction_IncomingImplCopyWithImpl<
          _$RecordedTransaction_IncomingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecordedTransactionIncoming field0) incoming,
    required TResult Function(RecordedTransactionOutgoing field0) outgoing,
  }) {
    return incoming(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecordedTransactionIncoming field0)? incoming,
    TResult? Function(RecordedTransactionOutgoing field0)? outgoing,
  }) {
    return incoming?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecordedTransactionIncoming field0)? incoming,
    TResult Function(RecordedTransactionOutgoing field0)? outgoing,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RecordedTransaction_Incoming value) incoming,
    required TResult Function(RecordedTransaction_Outgoing value) outgoing,
  }) {
    return incoming(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RecordedTransaction_Incoming value)? incoming,
    TResult? Function(RecordedTransaction_Outgoing value)? outgoing,
  }) {
    return incoming?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RecordedTransaction_Incoming value)? incoming,
    TResult Function(RecordedTransaction_Outgoing value)? outgoing,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(this);
    }
    return orElse();
  }
}

abstract class RecordedTransaction_Incoming extends RecordedTransaction {
  const factory RecordedTransaction_Incoming(
          final RecordedTransactionIncoming field0) =
      _$RecordedTransaction_IncomingImpl;
  const RecordedTransaction_Incoming._() : super._();

  @override
  RecordedTransactionIncoming get field0;

  /// Create a copy of RecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RecordedTransaction_IncomingImplCopyWith<
          _$RecordedTransaction_IncomingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RecordedTransaction_OutgoingImplCopyWith<$Res> {
  factory _$$RecordedTransaction_OutgoingImplCopyWith(
          _$RecordedTransaction_OutgoingImpl value,
          $Res Function(_$RecordedTransaction_OutgoingImpl) then) =
      __$$RecordedTransaction_OutgoingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecordedTransactionOutgoing field0});
}

/// @nodoc
class __$$RecordedTransaction_OutgoingImplCopyWithImpl<$Res>
    extends _$RecordedTransactionCopyWithImpl<$Res,
        _$RecordedTransaction_OutgoingImpl>
    implements _$$RecordedTransaction_OutgoingImplCopyWith<$Res> {
  __$$RecordedTransaction_OutgoingImplCopyWithImpl(
      _$RecordedTransaction_OutgoingImpl _value,
      $Res Function(_$RecordedTransaction_OutgoingImpl) _then)
      : super(_value, _then);

  /// Create a copy of RecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RecordedTransaction_OutgoingImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as RecordedTransactionOutgoing,
    ));
  }
}

/// @nodoc

class _$RecordedTransaction_OutgoingImpl extends RecordedTransaction_Outgoing {
  const _$RecordedTransaction_OutgoingImpl(this.field0) : super._();

  @override
  final RecordedTransactionOutgoing field0;

  @override
  String toString() {
    return 'RecordedTransaction.outgoing(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecordedTransaction_OutgoingImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RecordedTransaction_OutgoingImplCopyWith<
          _$RecordedTransaction_OutgoingImpl>
      get copyWith => __$$RecordedTransaction_OutgoingImplCopyWithImpl<
          _$RecordedTransaction_OutgoingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecordedTransactionIncoming field0) incoming,
    required TResult Function(RecordedTransactionOutgoing field0) outgoing,
  }) {
    return outgoing(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecordedTransactionIncoming field0)? incoming,
    TResult? Function(RecordedTransactionOutgoing field0)? outgoing,
  }) {
    return outgoing?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecordedTransactionIncoming field0)? incoming,
    TResult Function(RecordedTransactionOutgoing field0)? outgoing,
    required TResult orElse(),
  }) {
    if (outgoing != null) {
      return outgoing(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RecordedTransaction_Incoming value) incoming,
    required TResult Function(RecordedTransaction_Outgoing value) outgoing,
  }) {
    return outgoing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RecordedTransaction_Incoming value)? incoming,
    TResult? Function(RecordedTransaction_Outgoing value)? outgoing,
  }) {
    return outgoing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RecordedTransaction_Incoming value)? incoming,
    TResult Function(RecordedTransaction_Outgoing value)? outgoing,
    required TResult orElse(),
  }) {
    if (outgoing != null) {
      return outgoing(this);
    }
    return orElse();
  }
}

abstract class RecordedTransaction_Outgoing extends RecordedTransaction {
  const factory RecordedTransaction_Outgoing(
          final RecordedTransactionOutgoing field0) =
      _$RecordedTransaction_OutgoingImpl;
  const RecordedTransaction_Outgoing._() : super._();

  @override
  RecordedTransactionOutgoing get field0;

  /// Create a copy of RecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RecordedTransaction_OutgoingImplCopyWith<
          _$RecordedTransaction_OutgoingImpl>
      get copyWith => throw _privateConstructorUsedError;
}
