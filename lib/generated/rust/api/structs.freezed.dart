// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'structs.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ApiOutputSpendStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiOutputSpendStatus_Unspent value) unspent,
    required TResult Function(ApiOutputSpendStatus_Spent value) spent,
    required TResult Function(ApiOutputSpendStatus_Mined value) mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult? Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult? Function(ApiOutputSpendStatus_Mined value)? mined,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult Function(ApiOutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiOutputSpendStatusCopyWith<$Res> {
  factory $ApiOutputSpendStatusCopyWith(ApiOutputSpendStatus value,
          $Res Function(ApiOutputSpendStatus) then) =
      _$ApiOutputSpendStatusCopyWithImpl<$Res, ApiOutputSpendStatus>;
}

/// @nodoc
class _$ApiOutputSpendStatusCopyWithImpl<$Res,
        $Val extends ApiOutputSpendStatus>
    implements $ApiOutputSpendStatusCopyWith<$Res> {
  _$ApiOutputSpendStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ApiOutputSpendStatus_UnspentImplCopyWith<$Res> {
  factory _$$ApiOutputSpendStatus_UnspentImplCopyWith(
          _$ApiOutputSpendStatus_UnspentImpl value,
          $Res Function(_$ApiOutputSpendStatus_UnspentImpl) then) =
      __$$ApiOutputSpendStatus_UnspentImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ApiOutputSpendStatus_UnspentImplCopyWithImpl<$Res>
    extends _$ApiOutputSpendStatusCopyWithImpl<$Res,
        _$ApiOutputSpendStatus_UnspentImpl>
    implements _$$ApiOutputSpendStatus_UnspentImplCopyWith<$Res> {
  __$$ApiOutputSpendStatus_UnspentImplCopyWithImpl(
      _$ApiOutputSpendStatus_UnspentImpl _value,
      $Res Function(_$ApiOutputSpendStatus_UnspentImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ApiOutputSpendStatus_UnspentImpl extends ApiOutputSpendStatus_Unspent {
  const _$ApiOutputSpendStatus_UnspentImpl() : super._();

  @override
  String toString() {
    return 'ApiOutputSpendStatus.unspent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiOutputSpendStatus_UnspentImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return unspent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return unspent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (unspent != null) {
      return unspent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiOutputSpendStatus_Unspent value) unspent,
    required TResult Function(ApiOutputSpendStatus_Spent value) spent,
    required TResult Function(ApiOutputSpendStatus_Mined value) mined,
  }) {
    return unspent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult? Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult? Function(ApiOutputSpendStatus_Mined value)? mined,
  }) {
    return unspent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult Function(ApiOutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (unspent != null) {
      return unspent(this);
    }
    return orElse();
  }
}

abstract class ApiOutputSpendStatus_Unspent extends ApiOutputSpendStatus {
  const factory ApiOutputSpendStatus_Unspent() =
      _$ApiOutputSpendStatus_UnspentImpl;
  const ApiOutputSpendStatus_Unspent._() : super._();
}

/// @nodoc
abstract class _$$ApiOutputSpendStatus_SpentImplCopyWith<$Res> {
  factory _$$ApiOutputSpendStatus_SpentImplCopyWith(
          _$ApiOutputSpendStatus_SpentImpl value,
          $Res Function(_$ApiOutputSpendStatus_SpentImpl) then) =
      __$$ApiOutputSpendStatus_SpentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$ApiOutputSpendStatus_SpentImplCopyWithImpl<$Res>
    extends _$ApiOutputSpendStatusCopyWithImpl<$Res,
        _$ApiOutputSpendStatus_SpentImpl>
    implements _$$ApiOutputSpendStatus_SpentImplCopyWith<$Res> {
  __$$ApiOutputSpendStatus_SpentImplCopyWithImpl(
      _$ApiOutputSpendStatus_SpentImpl _value,
      $Res Function(_$ApiOutputSpendStatus_SpentImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$ApiOutputSpendStatus_SpentImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ApiOutputSpendStatus_SpentImpl extends ApiOutputSpendStatus_Spent {
  const _$ApiOutputSpendStatus_SpentImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'ApiOutputSpendStatus.spent(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiOutputSpendStatus_SpentImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiOutputSpendStatus_SpentImplCopyWith<_$ApiOutputSpendStatus_SpentImpl>
      get copyWith => __$$ApiOutputSpendStatus_SpentImplCopyWithImpl<
          _$ApiOutputSpendStatus_SpentImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return spent(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return spent?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (spent != null) {
      return spent(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiOutputSpendStatus_Unspent value) unspent,
    required TResult Function(ApiOutputSpendStatus_Spent value) spent,
    required TResult Function(ApiOutputSpendStatus_Mined value) mined,
  }) {
    return spent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult? Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult? Function(ApiOutputSpendStatus_Mined value)? mined,
  }) {
    return spent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult Function(ApiOutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (spent != null) {
      return spent(this);
    }
    return orElse();
  }
}

abstract class ApiOutputSpendStatus_Spent extends ApiOutputSpendStatus {
  const factory ApiOutputSpendStatus_Spent(final String field0) =
      _$ApiOutputSpendStatus_SpentImpl;
  const ApiOutputSpendStatus_Spent._() : super._();

  String get field0;

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiOutputSpendStatus_SpentImplCopyWith<_$ApiOutputSpendStatus_SpentImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ApiOutputSpendStatus_MinedImplCopyWith<$Res> {
  factory _$$ApiOutputSpendStatus_MinedImplCopyWith(
          _$ApiOutputSpendStatus_MinedImpl value,
          $Res Function(_$ApiOutputSpendStatus_MinedImpl) then) =
      __$$ApiOutputSpendStatus_MinedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$ApiOutputSpendStatus_MinedImplCopyWithImpl<$Res>
    extends _$ApiOutputSpendStatusCopyWithImpl<$Res,
        _$ApiOutputSpendStatus_MinedImpl>
    implements _$$ApiOutputSpendStatus_MinedImplCopyWith<$Res> {
  __$$ApiOutputSpendStatus_MinedImplCopyWithImpl(
      _$ApiOutputSpendStatus_MinedImpl _value,
      $Res Function(_$ApiOutputSpendStatus_MinedImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$ApiOutputSpendStatus_MinedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ApiOutputSpendStatus_MinedImpl extends ApiOutputSpendStatus_Mined {
  const _$ApiOutputSpendStatus_MinedImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'ApiOutputSpendStatus.mined(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiOutputSpendStatus_MinedImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiOutputSpendStatus_MinedImplCopyWith<_$ApiOutputSpendStatus_MinedImpl>
      get copyWith => __$$ApiOutputSpendStatus_MinedImplCopyWithImpl<
          _$ApiOutputSpendStatus_MinedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unspent,
    required TResult Function(String field0) spent,
    required TResult Function(String field0) mined,
  }) {
    return mined(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unspent,
    TResult? Function(String field0)? spent,
    TResult? Function(String field0)? mined,
  }) {
    return mined?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unspent,
    TResult Function(String field0)? spent,
    TResult Function(String field0)? mined,
    required TResult orElse(),
  }) {
    if (mined != null) {
      return mined(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiOutputSpendStatus_Unspent value) unspent,
    required TResult Function(ApiOutputSpendStatus_Spent value) spent,
    required TResult Function(ApiOutputSpendStatus_Mined value) mined,
  }) {
    return mined(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult? Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult? Function(ApiOutputSpendStatus_Mined value)? mined,
  }) {
    return mined?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiOutputSpendStatus_Unspent value)? unspent,
    TResult Function(ApiOutputSpendStatus_Spent value)? spent,
    TResult Function(ApiOutputSpendStatus_Mined value)? mined,
    required TResult orElse(),
  }) {
    if (mined != null) {
      return mined(this);
    }
    return orElse();
  }
}

abstract class ApiOutputSpendStatus_Mined extends ApiOutputSpendStatus {
  const factory ApiOutputSpendStatus_Mined(final String field0) =
      _$ApiOutputSpendStatus_MinedImpl;
  const ApiOutputSpendStatus_Mined._() : super._();

  String get field0;

  /// Create a copy of ApiOutputSpendStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiOutputSpendStatus_MinedImplCopyWith<_$ApiOutputSpendStatus_MinedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ApiRecordedTransaction {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ApiRecordedTransactionIncoming field0) incoming,
    required TResult Function(ApiRecordedTransactionOutgoing field0) outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ApiRecordedTransactionIncoming field0)? incoming,
    TResult? Function(ApiRecordedTransactionOutgoing field0)? outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ApiRecordedTransactionIncoming field0)? incoming,
    TResult Function(ApiRecordedTransactionOutgoing field0)? outgoing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiRecordedTransaction_Incoming value) incoming,
    required TResult Function(ApiRecordedTransaction_Outgoing value) outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiRecordedTransaction_Incoming value)? incoming,
    TResult? Function(ApiRecordedTransaction_Outgoing value)? outgoing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiRecordedTransaction_Incoming value)? incoming,
    TResult Function(ApiRecordedTransaction_Outgoing value)? outgoing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiRecordedTransactionCopyWith<$Res> {
  factory $ApiRecordedTransactionCopyWith(ApiRecordedTransaction value,
          $Res Function(ApiRecordedTransaction) then) =
      _$ApiRecordedTransactionCopyWithImpl<$Res, ApiRecordedTransaction>;
}

/// @nodoc
class _$ApiRecordedTransactionCopyWithImpl<$Res,
        $Val extends ApiRecordedTransaction>
    implements $ApiRecordedTransactionCopyWith<$Res> {
  _$ApiRecordedTransactionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ApiRecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ApiRecordedTransaction_IncomingImplCopyWith<$Res> {
  factory _$$ApiRecordedTransaction_IncomingImplCopyWith(
          _$ApiRecordedTransaction_IncomingImpl value,
          $Res Function(_$ApiRecordedTransaction_IncomingImpl) then) =
      __$$ApiRecordedTransaction_IncomingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ApiRecordedTransactionIncoming field0});
}

/// @nodoc
class __$$ApiRecordedTransaction_IncomingImplCopyWithImpl<$Res>
    extends _$ApiRecordedTransactionCopyWithImpl<$Res,
        _$ApiRecordedTransaction_IncomingImpl>
    implements _$$ApiRecordedTransaction_IncomingImplCopyWith<$Res> {
  __$$ApiRecordedTransaction_IncomingImplCopyWithImpl(
      _$ApiRecordedTransaction_IncomingImpl _value,
      $Res Function(_$ApiRecordedTransaction_IncomingImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiRecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$ApiRecordedTransaction_IncomingImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as ApiRecordedTransactionIncoming,
    ));
  }
}

/// @nodoc

class _$ApiRecordedTransaction_IncomingImpl
    extends ApiRecordedTransaction_Incoming {
  const _$ApiRecordedTransaction_IncomingImpl(this.field0) : super._();

  @override
  final ApiRecordedTransactionIncoming field0;

  @override
  String toString() {
    return 'ApiRecordedTransaction.incoming(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiRecordedTransaction_IncomingImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ApiRecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiRecordedTransaction_IncomingImplCopyWith<
          _$ApiRecordedTransaction_IncomingImpl>
      get copyWith => __$$ApiRecordedTransaction_IncomingImplCopyWithImpl<
          _$ApiRecordedTransaction_IncomingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ApiRecordedTransactionIncoming field0) incoming,
    required TResult Function(ApiRecordedTransactionOutgoing field0) outgoing,
  }) {
    return incoming(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ApiRecordedTransactionIncoming field0)? incoming,
    TResult? Function(ApiRecordedTransactionOutgoing field0)? outgoing,
  }) {
    return incoming?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ApiRecordedTransactionIncoming field0)? incoming,
    TResult Function(ApiRecordedTransactionOutgoing field0)? outgoing,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiRecordedTransaction_Incoming value) incoming,
    required TResult Function(ApiRecordedTransaction_Outgoing value) outgoing,
  }) {
    return incoming(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiRecordedTransaction_Incoming value)? incoming,
    TResult? Function(ApiRecordedTransaction_Outgoing value)? outgoing,
  }) {
    return incoming?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiRecordedTransaction_Incoming value)? incoming,
    TResult Function(ApiRecordedTransaction_Outgoing value)? outgoing,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(this);
    }
    return orElse();
  }
}

abstract class ApiRecordedTransaction_Incoming extends ApiRecordedTransaction {
  const factory ApiRecordedTransaction_Incoming(
          final ApiRecordedTransactionIncoming field0) =
      _$ApiRecordedTransaction_IncomingImpl;
  const ApiRecordedTransaction_Incoming._() : super._();

  @override
  ApiRecordedTransactionIncoming get field0;

  /// Create a copy of ApiRecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiRecordedTransaction_IncomingImplCopyWith<
          _$ApiRecordedTransaction_IncomingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ApiRecordedTransaction_OutgoingImplCopyWith<$Res> {
  factory _$$ApiRecordedTransaction_OutgoingImplCopyWith(
          _$ApiRecordedTransaction_OutgoingImpl value,
          $Res Function(_$ApiRecordedTransaction_OutgoingImpl) then) =
      __$$ApiRecordedTransaction_OutgoingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ApiRecordedTransactionOutgoing field0});
}

/// @nodoc
class __$$ApiRecordedTransaction_OutgoingImplCopyWithImpl<$Res>
    extends _$ApiRecordedTransactionCopyWithImpl<$Res,
        _$ApiRecordedTransaction_OutgoingImpl>
    implements _$$ApiRecordedTransaction_OutgoingImplCopyWith<$Res> {
  __$$ApiRecordedTransaction_OutgoingImplCopyWithImpl(
      _$ApiRecordedTransaction_OutgoingImpl _value,
      $Res Function(_$ApiRecordedTransaction_OutgoingImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiRecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$ApiRecordedTransaction_OutgoingImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as ApiRecordedTransactionOutgoing,
    ));
  }
}

/// @nodoc

class _$ApiRecordedTransaction_OutgoingImpl
    extends ApiRecordedTransaction_Outgoing {
  const _$ApiRecordedTransaction_OutgoingImpl(this.field0) : super._();

  @override
  final ApiRecordedTransactionOutgoing field0;

  @override
  String toString() {
    return 'ApiRecordedTransaction.outgoing(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiRecordedTransaction_OutgoingImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ApiRecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiRecordedTransaction_OutgoingImplCopyWith<
          _$ApiRecordedTransaction_OutgoingImpl>
      get copyWith => __$$ApiRecordedTransaction_OutgoingImplCopyWithImpl<
          _$ApiRecordedTransaction_OutgoingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ApiRecordedTransactionIncoming field0) incoming,
    required TResult Function(ApiRecordedTransactionOutgoing field0) outgoing,
  }) {
    return outgoing(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ApiRecordedTransactionIncoming field0)? incoming,
    TResult? Function(ApiRecordedTransactionOutgoing field0)? outgoing,
  }) {
    return outgoing?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ApiRecordedTransactionIncoming field0)? incoming,
    TResult Function(ApiRecordedTransactionOutgoing field0)? outgoing,
    required TResult orElse(),
  }) {
    if (outgoing != null) {
      return outgoing(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiRecordedTransaction_Incoming value) incoming,
    required TResult Function(ApiRecordedTransaction_Outgoing value) outgoing,
  }) {
    return outgoing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiRecordedTransaction_Incoming value)? incoming,
    TResult? Function(ApiRecordedTransaction_Outgoing value)? outgoing,
  }) {
    return outgoing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiRecordedTransaction_Incoming value)? incoming,
    TResult Function(ApiRecordedTransaction_Outgoing value)? outgoing,
    required TResult orElse(),
  }) {
    if (outgoing != null) {
      return outgoing(this);
    }
    return orElse();
  }
}

abstract class ApiRecordedTransaction_Outgoing extends ApiRecordedTransaction {
  const factory ApiRecordedTransaction_Outgoing(
          final ApiRecordedTransactionOutgoing field0) =
      _$ApiRecordedTransaction_OutgoingImpl;
  const ApiRecordedTransaction_Outgoing._() : super._();

  @override
  ApiRecordedTransactionOutgoing get field0;

  /// Create a copy of ApiRecordedTransaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiRecordedTransaction_OutgoingImplCopyWith<
          _$ApiRecordedTransaction_OutgoingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ApiSetupWalletType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newWallet,
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) full,
    required TResult Function(String field0, String field1) watchOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newWallet,
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? full,
    TResult? Function(String field0, String field1)? watchOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newWallet,
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? full,
    TResult Function(String field0, String field1)? watchOnly,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiSetupWalletType_NewWallet value) newWallet,
    required TResult Function(ApiSetupWalletType_Mnemonic value) mnemonic,
    required TResult Function(ApiSetupWalletType_Full value) full,
    required TResult Function(ApiSetupWalletType_WatchOnly value) watchOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult? Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult? Function(ApiSetupWalletType_Full value)? full,
    TResult? Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult Function(ApiSetupWalletType_Full value)? full,
    TResult Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiSetupWalletTypeCopyWith<$Res> {
  factory $ApiSetupWalletTypeCopyWith(
          ApiSetupWalletType value, $Res Function(ApiSetupWalletType) then) =
      _$ApiSetupWalletTypeCopyWithImpl<$Res, ApiSetupWalletType>;
}

/// @nodoc
class _$ApiSetupWalletTypeCopyWithImpl<$Res, $Val extends ApiSetupWalletType>
    implements $ApiSetupWalletTypeCopyWith<$Res> {
  _$ApiSetupWalletTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ApiSetupWalletType_NewWalletImplCopyWith<$Res> {
  factory _$$ApiSetupWalletType_NewWalletImplCopyWith(
          _$ApiSetupWalletType_NewWalletImpl value,
          $Res Function(_$ApiSetupWalletType_NewWalletImpl) then) =
      __$$ApiSetupWalletType_NewWalletImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ApiSetupWalletType_NewWalletImplCopyWithImpl<$Res>
    extends _$ApiSetupWalletTypeCopyWithImpl<$Res,
        _$ApiSetupWalletType_NewWalletImpl>
    implements _$$ApiSetupWalletType_NewWalletImplCopyWith<$Res> {
  __$$ApiSetupWalletType_NewWalletImplCopyWithImpl(
      _$ApiSetupWalletType_NewWalletImpl _value,
      $Res Function(_$ApiSetupWalletType_NewWalletImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ApiSetupWalletType_NewWalletImpl extends ApiSetupWalletType_NewWallet {
  const _$ApiSetupWalletType_NewWalletImpl() : super._();

  @override
  String toString() {
    return 'ApiSetupWalletType.newWallet()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiSetupWalletType_NewWalletImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newWallet,
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) full,
    required TResult Function(String field0, String field1) watchOnly,
  }) {
    return newWallet();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newWallet,
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? full,
    TResult? Function(String field0, String field1)? watchOnly,
  }) {
    return newWallet?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newWallet,
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? full,
    TResult Function(String field0, String field1)? watchOnly,
    required TResult orElse(),
  }) {
    if (newWallet != null) {
      return newWallet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiSetupWalletType_NewWallet value) newWallet,
    required TResult Function(ApiSetupWalletType_Mnemonic value) mnemonic,
    required TResult Function(ApiSetupWalletType_Full value) full,
    required TResult Function(ApiSetupWalletType_WatchOnly value) watchOnly,
  }) {
    return newWallet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult? Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult? Function(ApiSetupWalletType_Full value)? full,
    TResult? Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
  }) {
    return newWallet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult Function(ApiSetupWalletType_Full value)? full,
    TResult Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
    required TResult orElse(),
  }) {
    if (newWallet != null) {
      return newWallet(this);
    }
    return orElse();
  }
}

abstract class ApiSetupWalletType_NewWallet extends ApiSetupWalletType {
  const factory ApiSetupWalletType_NewWallet() =
      _$ApiSetupWalletType_NewWalletImpl;
  const ApiSetupWalletType_NewWallet._() : super._();
}

/// @nodoc
abstract class _$$ApiSetupWalletType_MnemonicImplCopyWith<$Res> {
  factory _$$ApiSetupWalletType_MnemonicImplCopyWith(
          _$ApiSetupWalletType_MnemonicImpl value,
          $Res Function(_$ApiSetupWalletType_MnemonicImpl) then) =
      __$$ApiSetupWalletType_MnemonicImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$ApiSetupWalletType_MnemonicImplCopyWithImpl<$Res>
    extends _$ApiSetupWalletTypeCopyWithImpl<$Res,
        _$ApiSetupWalletType_MnemonicImpl>
    implements _$$ApiSetupWalletType_MnemonicImplCopyWith<$Res> {
  __$$ApiSetupWalletType_MnemonicImplCopyWithImpl(
      _$ApiSetupWalletType_MnemonicImpl _value,
      $Res Function(_$ApiSetupWalletType_MnemonicImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$ApiSetupWalletType_MnemonicImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ApiSetupWalletType_MnemonicImpl extends ApiSetupWalletType_Mnemonic {
  const _$ApiSetupWalletType_MnemonicImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'ApiSetupWalletType.mnemonic(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiSetupWalletType_MnemonicImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiSetupWalletType_MnemonicImplCopyWith<_$ApiSetupWalletType_MnemonicImpl>
      get copyWith => __$$ApiSetupWalletType_MnemonicImplCopyWithImpl<
          _$ApiSetupWalletType_MnemonicImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newWallet,
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) full,
    required TResult Function(String field0, String field1) watchOnly,
  }) {
    return mnemonic(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newWallet,
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? full,
    TResult? Function(String field0, String field1)? watchOnly,
  }) {
    return mnemonic?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newWallet,
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? full,
    TResult Function(String field0, String field1)? watchOnly,
    required TResult orElse(),
  }) {
    if (mnemonic != null) {
      return mnemonic(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiSetupWalletType_NewWallet value) newWallet,
    required TResult Function(ApiSetupWalletType_Mnemonic value) mnemonic,
    required TResult Function(ApiSetupWalletType_Full value) full,
    required TResult Function(ApiSetupWalletType_WatchOnly value) watchOnly,
  }) {
    return mnemonic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult? Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult? Function(ApiSetupWalletType_Full value)? full,
    TResult? Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
  }) {
    return mnemonic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult Function(ApiSetupWalletType_Full value)? full,
    TResult Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
    required TResult orElse(),
  }) {
    if (mnemonic != null) {
      return mnemonic(this);
    }
    return orElse();
  }
}

abstract class ApiSetupWalletType_Mnemonic extends ApiSetupWalletType {
  const factory ApiSetupWalletType_Mnemonic(final String field0) =
      _$ApiSetupWalletType_MnemonicImpl;
  const ApiSetupWalletType_Mnemonic._() : super._();

  String get field0;

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiSetupWalletType_MnemonicImplCopyWith<_$ApiSetupWalletType_MnemonicImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ApiSetupWalletType_FullImplCopyWith<$Res> {
  factory _$$ApiSetupWalletType_FullImplCopyWith(
          _$ApiSetupWalletType_FullImpl value,
          $Res Function(_$ApiSetupWalletType_FullImpl) then) =
      __$$ApiSetupWalletType_FullImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1});
}

/// @nodoc
class __$$ApiSetupWalletType_FullImplCopyWithImpl<$Res>
    extends _$ApiSetupWalletTypeCopyWithImpl<$Res,
        _$ApiSetupWalletType_FullImpl>
    implements _$$ApiSetupWalletType_FullImplCopyWith<$Res> {
  __$$ApiSetupWalletType_FullImplCopyWithImpl(
      _$ApiSetupWalletType_FullImpl _value,
      $Res Function(_$ApiSetupWalletType_FullImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$ApiSetupWalletType_FullImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ApiSetupWalletType_FullImpl extends ApiSetupWalletType_Full {
  const _$ApiSetupWalletType_FullImpl(this.field0, this.field1) : super._();

  @override
  final String field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'ApiSetupWalletType.full(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiSetupWalletType_FullImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiSetupWalletType_FullImplCopyWith<_$ApiSetupWalletType_FullImpl>
      get copyWith => __$$ApiSetupWalletType_FullImplCopyWithImpl<
          _$ApiSetupWalletType_FullImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newWallet,
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) full,
    required TResult Function(String field0, String field1) watchOnly,
  }) {
    return full(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newWallet,
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? full,
    TResult? Function(String field0, String field1)? watchOnly,
  }) {
    return full?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newWallet,
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? full,
    TResult Function(String field0, String field1)? watchOnly,
    required TResult orElse(),
  }) {
    if (full != null) {
      return full(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiSetupWalletType_NewWallet value) newWallet,
    required TResult Function(ApiSetupWalletType_Mnemonic value) mnemonic,
    required TResult Function(ApiSetupWalletType_Full value) full,
    required TResult Function(ApiSetupWalletType_WatchOnly value) watchOnly,
  }) {
    return full(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult? Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult? Function(ApiSetupWalletType_Full value)? full,
    TResult? Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
  }) {
    return full?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult Function(ApiSetupWalletType_Full value)? full,
    TResult Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
    required TResult orElse(),
  }) {
    if (full != null) {
      return full(this);
    }
    return orElse();
  }
}

abstract class ApiSetupWalletType_Full extends ApiSetupWalletType {
  const factory ApiSetupWalletType_Full(
      final String field0, final String field1) = _$ApiSetupWalletType_FullImpl;
  const ApiSetupWalletType_Full._() : super._();

  String get field0;
  String get field1;

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiSetupWalletType_FullImplCopyWith<_$ApiSetupWalletType_FullImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ApiSetupWalletType_WatchOnlyImplCopyWith<$Res> {
  factory _$$ApiSetupWalletType_WatchOnlyImplCopyWith(
          _$ApiSetupWalletType_WatchOnlyImpl value,
          $Res Function(_$ApiSetupWalletType_WatchOnlyImpl) then) =
      __$$ApiSetupWalletType_WatchOnlyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1});
}

/// @nodoc
class __$$ApiSetupWalletType_WatchOnlyImplCopyWithImpl<$Res>
    extends _$ApiSetupWalletTypeCopyWithImpl<$Res,
        _$ApiSetupWalletType_WatchOnlyImpl>
    implements _$$ApiSetupWalletType_WatchOnlyImplCopyWith<$Res> {
  __$$ApiSetupWalletType_WatchOnlyImplCopyWithImpl(
      _$ApiSetupWalletType_WatchOnlyImpl _value,
      $Res Function(_$ApiSetupWalletType_WatchOnlyImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$ApiSetupWalletType_WatchOnlyImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ApiSetupWalletType_WatchOnlyImpl extends ApiSetupWalletType_WatchOnly {
  const _$ApiSetupWalletType_WatchOnlyImpl(this.field0, this.field1)
      : super._();

  @override
  final String field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'ApiSetupWalletType.watchOnly(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiSetupWalletType_WatchOnlyImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiSetupWalletType_WatchOnlyImplCopyWith<
          _$ApiSetupWalletType_WatchOnlyImpl>
      get copyWith => __$$ApiSetupWalletType_WatchOnlyImplCopyWithImpl<
          _$ApiSetupWalletType_WatchOnlyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newWallet,
    required TResult Function(String field0) mnemonic,
    required TResult Function(String field0, String field1) full,
    required TResult Function(String field0, String field1) watchOnly,
  }) {
    return watchOnly(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newWallet,
    TResult? Function(String field0)? mnemonic,
    TResult? Function(String field0, String field1)? full,
    TResult? Function(String field0, String field1)? watchOnly,
  }) {
    return watchOnly?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newWallet,
    TResult Function(String field0)? mnemonic,
    TResult Function(String field0, String field1)? full,
    TResult Function(String field0, String field1)? watchOnly,
    required TResult orElse(),
  }) {
    if (watchOnly != null) {
      return watchOnly(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ApiSetupWalletType_NewWallet value) newWallet,
    required TResult Function(ApiSetupWalletType_Mnemonic value) mnemonic,
    required TResult Function(ApiSetupWalletType_Full value) full,
    required TResult Function(ApiSetupWalletType_WatchOnly value) watchOnly,
  }) {
    return watchOnly(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult? Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult? Function(ApiSetupWalletType_Full value)? full,
    TResult? Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
  }) {
    return watchOnly?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ApiSetupWalletType_NewWallet value)? newWallet,
    TResult Function(ApiSetupWalletType_Mnemonic value)? mnemonic,
    TResult Function(ApiSetupWalletType_Full value)? full,
    TResult Function(ApiSetupWalletType_WatchOnly value)? watchOnly,
    required TResult orElse(),
  }) {
    if (watchOnly != null) {
      return watchOnly(this);
    }
    return orElse();
  }
}

abstract class ApiSetupWalletType_WatchOnly extends ApiSetupWalletType {
  const factory ApiSetupWalletType_WatchOnly(
          final String field0, final String field1) =
      _$ApiSetupWalletType_WatchOnlyImpl;
  const ApiSetupWalletType_WatchOnly._() : super._();

  String get field0;
  String get field1;

  /// Create a copy of ApiSetupWalletType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiSetupWalletType_WatchOnlyImplCopyWith<
          _$ApiSetupWalletType_WatchOnlyImpl>
      get copyWith => throw _privateConstructorUsedError;
}
