import 'package:auto_size_text/auto_size_text.dart';
import 'package:bitcoin_ui/bitcoin_ui.dart';
import 'package:danawallet/data/enums/network.dart';
import 'package:danawallet/data/enums/warning_type.dart';
import 'package:danawallet/global_functions.dart';
import 'package:danawallet/screens/onboarding/dana_address_setup.dart';
import 'package:danawallet/services/dana_address_service.dart';
import 'package:danawallet/states/chain_state.dart';
import 'package:danawallet/states/scan_progress_notifier.dart';
import 'package:danawallet/states/wallet_state.dart';
import 'package:danawallet/widgets/back_button.dart';
import 'package:danawallet/widgets/buttons/footer/footer_button.dart';
import 'package:danawallet/widgets/pills/mnemonic_input_pill_box.dart';
import 'package:danawallet/widgets/pin_guard.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:sizer/sizer.dart';

const String bandwidthWarning =
    "The recovery process may require a lot of network usage. Please make sure you are connected to wifi before you continue.";

const int _mnemonicCount = 12;

class SeedPhraseScreen extends StatefulWidget {
  final List<String> bip39Words;
  final Network network;
  const SeedPhraseScreen({
    super.key,
    required this.bip39Words,
    required this.network,
  });

  @override
  State<SeedPhraseScreen> createState() => SeedPhraseScreenState();
}

class SeedPhraseScreenState extends State<SeedPhraseScreen> {
  late List<TextEditingController> controllers;
  late List<FocusNode> focusNodes;
  late MnemonicInputPillBox pills;

  Future<void> onRestore(BuildContext context) async {
    try {
      final mnemonic = pills.mnemonic;
      final walletState = Provider.of<WalletState>(context, listen: false);
      final chainState = Provider.of<ChainState>(context, listen: false);
      final scanProgress =
          Provider.of<ScanProgressNotifier>(context, listen: false);

      final blindbitUrl = widget.network.defaultBlindbitUrl;

      await walletState.restoreWallet(widget.network, mnemonic);

      chainState.initialize(widget.network);
      // we can safely ignore the result of connecting, since we use the default birthday
      await chainState.connect(blindbitUrl);

      chainState.startSyncService(walletState, scanProgress, true);

      // Now we need to find out if the wallet has a dana address
      final hasDanaAddress = await walletState.tryLoadingDanaAddress();

      if ((widget.network == Network.regtest || hasDanaAddress) && context.mounted) {
        Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(builder: (context) => const PinGuard()),
            (Route<dynamic> route) => false);
      } else {
        // no dana address, so go to create dana address flow
        final suggestedUsername = await walletState.createSuggestedUsername();
        final danaAddressDomain = await DanaAddressService().danaAddressDomain;
        if (context.mounted) {
          Navigator.pushAndRemoveUntil(
              context,
              MaterialPageRoute(
                  builder: (context) => DanaAddressSetupScreen(
                      suggestedUsername: suggestedUsername,
                      domain: danaAddressDomain,
                      network: widget.network)),
              (Route<dynamic> route) => false);
        }
      }
    } catch (e) {
      if (context.mounted) {
        displayError("Restore failed", e);
      }
    }
  }

  @override
  void initState() {
    super.initState();

    controllers = List.generate(_mnemonicCount, (i) => TextEditingController());
    focusNodes = List.generate(_mnemonicCount, (i) => FocusNode());
    pills = MnemonicInputPillBox(
      validWords: widget.bip39Words,
      controllers: controllers,
      focusNodes: focusNodes,
    );

    // add warning message about bandwidth after building
    WidgetsBinding.instance.addPostFrameCallback((_) {
      showWarningDialog(bandwidthWarning, WarningType.info);
    });
  }

  @override
  void dispose() {
    for (int i = 0; i < _mnemonicCount; i++) {
      // dispose controllers and focusnodes
      controllers[i].dispose();
      focusNodes[i].dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final title = AutoSizeText(
      "Enter your recovery phrase",
      style: BitcoinTextStyle.title2(Colors.black)
          .copyWith(height: 1.8, fontFamily: 'Inter'),
      maxLines: 1,
    );

    final text = AutoSizeText(
      "Enter your recovery phrase. Don't enter a recovery phrase that wasn't generated by Dana!",
      style: BitcoinTextStyle.body3(Bitcoin.neutral7).copyWith(
        fontFamily: 'Inter',
      ),
      textAlign: TextAlign.center,
      maxLines: 3,
    );

    final footer =
        FooterButton(title: "Import", onPressed: () => onRestore(context));

    // footer padding, reduced when keyboard is open
    final keyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
    final bottomPaddingPercentage = keyboardOpen ? 1 : 5;

    return Scaffold(
        appBar: AppBar(
          automaticallyImplyLeading: false,
          title: const BackButtonWidget(),
        ),
        body: SafeArea(
          child: Padding(
              padding: EdgeInsets.fromLTRB(
                Adaptive.w(5), // Responsive left padding
                0,
                Adaptive.w(5), // Responsive right padding
                Adaptive.h(
                    bottomPaddingPercentage), // Responsive bottom padding
              ),
              child: Column(
                children: [
                  Column(
                    children: [
                      title,
                      Padding(
                          padding: EdgeInsets.symmetric(
                              vertical: Adaptive.h(3),
                              horizontal: Adaptive.w(2)),
                          child: text),
                    ],
                  ),
                  Expanded(child: pills),
                  footer,
                ],
              )),
        ));
  }
}
